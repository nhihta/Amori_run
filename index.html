<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <!-- Thay dòng meta viewport hiện tại bằng dòng này -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <title>Amori Runner — Order không suy Nghĩ</title>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2L0N4MY30Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-2L0N4MY30Y');
  </script>

  <!-- Open Graph cho Facebook -->
  <link rel="icon" type="image/png" href="https://github.com/nhihta/Amori_run/blob/main/imganhzalo.png?raw=true">
  <meta property="og:title" content="Game Amori Runner trên AhaFood.AI" />
  <meta property="og:description" content="Chơi game Amori Runner vui nhộn và đặt món ngay trên AhaFood.AI!" />
  <meta property="og:image" content="https://github.com/nhihta/Amori_run/blob/main/imganhzalo.png?raw=true" />
  <meta property="og:url" content="https://ahafood.ai/store" />
  <meta property="og:type" content="website" />

  <!-- Zalo Link Preview -->
  <meta name="zalo:image" content="https://github.com/nhihta/Amori_run/blob/main/imganhzalo.png?raw=true" />
  <meta name="zalo:title" content="Game Amori Runner trên AhaFood.AI" />
  <meta name="zalo:description" content="Chơi game Amori Runner vui nhộn và đặt món ngay trên AhaFood.AI!" />
  <style>
    :root {
      --sky: #b3e5ff;
      --ground: #ffd37d;
      --cactus: #19c37d;
      --hole: #1f2937;
      --accent: #ff6b6b;
      --ui: #0f172a;
        /* Safe-area (iOS notch) */
  --safe-top: env(safe-area-inset-top);
  --safe-right: env(safe-area-inset-right);
  --safe-bottom: env(safe-area-inset-bottom);
  --safe-left: env(safe-area-inset-left);
    }

    html,
    body {
  height: 100dvh;              /* ưu tiên dynamic viewport */
  margin: 0;
  overflow: hidden;
  background: linear-gradient(180deg, var(--sky), #d9f6ff 60%);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue";
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none; user-select: none;
  overscroll-behavior: none;
    }

    /* Fallback nếu trình duyệt chưa hỗ trợ 100dvh */
@supports not (height: 100dvh){
  html, body{ height: 100vh; }
}


   /* Canvas phủ sát mép thiết bị (edge-to-edge) */
canvas{
  position: fixed;
  inset: 0;                 /* top/right/bottom/left: 0 */
  width: 100vw;
  height: 100dvh;
  display: block;
  background: linear-gradient(180deg, var(--sky), var(--sky) 70%, var(--ground) 70%, var(--ground));
  touch-action: none;
}
@supports not (height: 100dvh){
  canvas{ height: 100vh; }
}

/* Các lớp UI được “đệm” khỏi vùng tai thỏ */
.hint{
  position: fixed;
  top: calc(8px + var(--safe-top));
  left: calc(16px + var(--safe-left));
  right: calc(16px + var(--safe-right));
  text-align: center;
  color: var(--ui);
  font-weight: 600;
  z-index: 10;
}

.credit{
  position: fixed;
  bottom: calc(8px + var(--safe-bottom));
  right: calc(12px + var(--safe-right));
  color: #334155;
  font-size: 12px;
  opacity: .75;
  z-index: 10;
}

/* Giảm kích thước CTA khi màn hình ngang */
@media (orientation: landscape) {
  #promo .promo-box {
    width: 200px;   /* thay vì 92vmin */
    height: 280px;  /* hạ chiều cao tổng thể */
  }

  #promo img {
    max-height: calc(70vh - 80px); /* chừa chỗ cho nút */
  }

  #promo .promo-btn {
    font-size: 13px;
    margin-top: -5px;
    padding: 6px 14px;
    min-width: 100px;
  }
}


    /* === Promo overlay === */
    #promo.promo-hidden {
      display: none;
    }

    #promo {
  position: fixed;
  inset: 0;
  display: flex; align-items: center; justify-content: center;
  background: rgba(0,0,0,.55);
  z-index: 9999;
  padding:
    max(16px, var(--safe-top))
    max(16px, var(--safe-right))
    max(16px, var(--safe-bottom))
    max(16px, var(--safe-left));
    }

    /* Hộp CTA: xếp dọc ảnh + nút */
    #promo .promo-box {
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .35);
      text-align: center;
      overflow: hidden;

      display: flex;
      flex-direction: column;
      align-items: center;

      max-width: min(92vmin, 520px);
      /* theo cạnh ngắn, giới hạn 520px */
      max-height: 90vh;
      /* không vượt quá chiều cao màn hình */
    }

    /* Ảnh KHÔNG được chiếm hết 90vh — chừa chỗ cho nút */
    #promo img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      max-height: calc(90vh - 80px);
      /* ✅ chừa ~80px cho nút + khoảng cách */
    }

    /* Nút nằm dưới ảnh, nhỏ gọn và nền cam */
    #promo .promo-btn {
      margin: 0px 0 16px;
      padding: 5px 16px;
      background: #ff7f32;
      /* cam */
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      border-radius: 8px;
      text-decoration: none;
      box-shadow: 0 4px 12px rgba(255, 127, 50, .35);
      width: auto;
      min-width: 120px;
      /* nhỏ gọn theo chữ */
    }

    #promo .promo-btn:active {
      transform: translateY(1px);
    }

    /* Tối ưu thêm cho dọc */
    @media (orientation:portrait) {
      #promo .promo-box {
        max-height: 88vh;
      }

      #promo img {
        max-height: calc(88vh - 80px);
      }
    }


    /* phần ảnh lúc bắt đầu */
    /* === START UI (màn hình chờ) === */
    .start-hidden {
      display: none;
    }

    #startUI {
  position: fixed; inset: 0;
  display: flex; align-items:center; justify-content:center;
  z-index: 5000; pointer-events:auto; background: transparent;
  padding:
    max(16px, var(--safe-top))
    max(16px, var(--safe-right))
    max(16px, var(--safe-bottom))
    max(16px, var(--safe-left));
    }

    .start-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    /* Ảnh chiếm ~90% cạnh ngắn của màn hình, tự co theo xoay */
    #startImg {
      width: 90vmin;
      /* 90% cạnh ngắn của viewport (dọc/ ngang đều đẹp) */
      max-width: 1000px;
      height: auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
    }

    /* Khi màn hình ngang rộng → cho to hơn */
    @media (orientation: landscape) {
      #startImg {
        width: 70vw;
        /* chiếm 70% chiều rộng màn hình */
        max-width: 1200px;
        /* cho phép rộng hơn nếu màn hình lớn */
      }
    }

    /* nhóm nút */
    .start-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* nút */
    .start-btn {
      appearance: none;
      border: 0;
      cursor: pointer;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, .15);
    }

    /* nút Bắt đầu (cam) */
    #btnStart {
      background: #ff7a00;
      color: #fff;
    }

    #btnStart:active {
      transform: translateY(1px);
    }

    /* nút Tìm hiểu thêm (viền cam) */
    #btnMore {
      background: #fff;
      color: #ff7a00;
      border: 2px solid #ff7a00;
    }

    .start-hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <canvas id="game" width="900" height="280"></canvas>
  <!-- START UI: hiện khi chưa bắt đầu -->
  <div id="startUI" class="start-hidden">
    <div class="start-box">
      <!-- thay bằng ảnh của bạn; ảnh lớn sẽ tự co về 90vmin -->
      <img id="startImg" src="banner.jpg" alt="AhaFood.AI" />
      <div class="start-actions">
        <button id="btnStart" class="start-btn">Bắt đầu</button>
        <button id="btnMore" class="start-btn">Tìm hiểu thêm</button>
      </div>
    </div>
  </div>

  <!-- Overlay promo khi game over -->
  <div id="promo" class="promo-hidden">
    <div class="promo-box">
      <img src="CTA.jpg" alt="AhaFood.AI - gợi ý món theo tâm trạng"><br>
      <a class="promo-btn" href="https://bit.ly/46dGFUs" target="_blank" rel="noopener">
        Thử Ngay
      </a>
      <small id="btnRestart" style="color:red; margin-top:-8px; cursor:pointer">
        * Chạm để bắt đầu lại
      </small>

    </div>

  </div>


  <!-- Nút xoay màn hình -->
  <div class="hint" style="font-size: 13px;">Nhấn <span style="color:var(--accent);">Chạm để bắt đầu</div>
  <div class="credit">Xoay màn hình ngang để có trải nghiệm tốt nhất</div>

  <script>
    (() => {
      const cvs = document.getElementById('game');
      const ctx = cvs.getContext('2d');

      // === BRAND COLORS ===
      const BRAND_ORANGE = '#ff7f32'; // cam AhaFood.AI
      const BRAND_BLUE = '#0d4073'; // xanh AhaFood.AI
      // === ÂM THANH ===
      const bgm = new Audio('bgm.mp3');   // nhạc nền
      bgm.loop = true;
      bgm.volume = 0.5;

      const sJump = new Audio('jump.mp3');  // âm thanh nhảy
      sJump.volume = 0.9;

      const sOver = new Audio('over.mp3');  // âm thanh thua

      // Tự tạm dừng khi tab bị ẩn
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) bgm.pause();
        else if (running && !gameOver) bgm.play().catch(() => { });
      });

      // Promo overlay
      const promoEl = document.getElementById('promo');
      const btnRestart = document.getElementById('btnRestart');
      if (btnRestart) {
        btnRestart.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation(); // không dính event overlay/CTA
          hidePromo();
          reset();
          start();
        });
      }

      let promoShown = false;
      function showPromo() { if (!promoShown) { promoEl.classList.remove('promo-hidden'); promoShown = true; } }
      function hidePromo() { promoEl.classList.add('promo-hidden'); promoShown = false; }





      // === SPRITE (ảnh PNG của bạn) ===
      const SPRITE = new Image();
      SPRITE.src = "lasticon.png"; // TODO: đổi thành URL/đường dẫn ảnh của bạn

      // === COLLECTIBLE ICONS ===
      const ICON_SRC = [
        "icons/tea.png",      // trà sữa
        "icons/noodles.png",  // tô mì
        "icons/coffee.png",   // ly cà phê
        "icons/pizza.png",    // bánh pizza
        "icons/chicken-leg.png",
        "icons/rice.png"   // gà rán
      ];
      const ICONS = ICON_SRC.map(src => { const im = new Image(); im.src = src; return im; });

      // (tuỳ chọn) âm thanh nhặt đồ
      const sPickup = new Audio('pickup.mp3');
      sPickup.volume = 0.9;

      // ---- KÍCH THƯỚC DINO (chỉ đổi ở đây) ----


      const DINO_HEIGHT = 84; // đổi số này để to/nhỏ
      let DINO_WIDTH = 44;    // sẽ tính từ tỉ lệ ảnh khi ảnh load xong

      function applySpriteSize() {
        const aspect = (SPRITE.width && SPRITE.height) ? SPRITE.width / SPRITE.height : 1;
        DINO_WIDTH = Math.round(DINO_HEIGHT * aspect);
        dino.w = DINO_WIDTH;
        dino.h = DINO_HEIGHT;
        dino.y = groundYAt(dino.x) - dino.h;   // chân chạm đất
      }

      function onSpriteReady() {
        applySpriteSize();
        reset();            // chỉ reset khi ảnh đã sẵn sàng
        draw();             // vẽ lại màn hình chờ bằng ảnh thật
      }

      SPRITE.onload = onSpriteReady;
      // Nếu ảnh đã cache sẵn (load cực nhanh) thì gọi luôn:
      if (SPRITE.complete) onSpriteReady();


      // === HẰNG SỐ ===
      const GRAVITY = 0.62;          // rơi chậm hơn -> dễ canh
      const JUMP_VELOCITY = -17.5;   // bật cao & nhạy hơn
      const BASE_SPEED = 4.6;        // tốc độ nền chậm lại

      // --- VỊ TRÍ DINO THEO TỈ LỆ MÀN HÌNH ---
      const DINO_X_RATIO = 0.06;   // 6% bề ngang màn hình (đổi số nếu muốn sát/tránh mép)
      const DINO_X_MIN = 20;     // không cho sát mép quá

      function positionDinoX() {
        dino.x = Math.max(DINO_X_MIN, Math.round(cvs.width * DINO_X_RATIO));
      }

      // Địa hình: đường cơ sở dao động quanh 78% chiều cao
      const HILLS = {
        amp1: 21, len1: 700,   // sóng mượt, chu kỳ dài
        amp2: 10, len2: 400    // sóng phụ, chi tiết nhỏ
      };

      const startUI = document.getElementById('startUI');
      const btnStart = document.getElementById('btnStart');
      const btnMore = document.getElementById('btnMore');

      function showStartUI() { startUI.classList.remove('start-hidden'); }
      function hideStartUI() { startUI.classList.add('start-hidden'); }

      // click nút
      btnStart.onclick = () => { start(); };


      btnMore.onclick = () => { window.open('https://ahafood.ai/store', '_blank', 'noopener'); };


      // === TRẠNG THÁI ===
      let groundBase;                 // y cơ sở (phụ thuộc kích thước màn hình)
      let scroll = 0;                 // offset cuộn thế giới
      let worldSpeed = BASE_SPEED;
      let tick = 0, score = 0;
      let hiscore = +localStorage.getItem('dino_hiscore_v4') || 0;
      let running = false, gameOver = false;
      // --- WEATHER STATE ---
      let weather = "day";         // day | night | rain
      let stars = [];
      let raindrops = [];

      // === AMORI LETTERS ===
      const LETTERS = ['A', 'M', 'O', 'R', 'I'];
      let letterItems = [];              // các icon chữ đang bay
      let collectedLetters = new Set();  // các chữ đã nhặt
      let amoriCloudUntil = 0;           // timestamp ms -> hiện mây "AMORI" đến khi nào




      let rafId = null;
      // Jump leniency
      const COYOTE_TIME_MS = 120;
      const JUMP_BUFFER_MS = 150;

      let coyoteLeft = 0;   // thời gian còn lại được phép nhảy sau khi rời đất
      let bufferLeft = 0;   // thời gian còn lại lệnh nhảy đã bấm sớm


      //nổ
      // --- EXPLOSION STATE ---
      let exploding = false;
      let particles = [];     // các hạt nổ
      const EXPLOSION_LIFE = 50;  // số frame tối đa mỗi hạt

      function spawnExplosion(cx, cy) {
        exploding = true;
        particles.length = 0;
        const count = 80; // số hạt nổ
        for (let i = 0; i < count; i++) {
          const ang = Math.random() * Math.PI * 2;
          const spd = 2.5 + Math.random() * 4.5;    // tốc độ ban đầu
          particles.push({
            x: cx, y: cy,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd - 2,            // hơi bốc lên
            life: EXPLOSION_LIFE,
            size: 2 + Math.random() * 3,
            color: (i % 3 === 0 ? '#f97316' : i % 3 === 1 ? '#facc15' : '#ef4444') // cam / vàng / đỏ
          });
        }
      }


      const dino = { x: 100, y: 0, vy: 0, w: 44, h: 52, onGround: false };
      dino.h = DINO_HEIGHT;
      dino.w = DINO_WIDTH;

      const obstacles = [], clouds = []; const items = [];
      function rand(a, b) { return Math.random() * (b - a) + a }
      function irand(a, b) { return Math.floor(rand(a, b)) }

      // === ĐỊA HÌNH: y mặt đất tại toạ độ màn hình x (có tính cuộn) ===
      function groundYAt(screenX) {
        const worldX = scroll + screenX;
        // 2 sóng sin chồng nhau để tạo dốc mềm mại
        const y = groundBase
          + HILLS.amp1 * Math.sin((worldX) / HILLS.len1 * 2 * Math.PI)
          + HILLS.amp2 * Math.sin((worldX) / HILLS.len2 * 2 * Math.PI + 1.2);
        return y | 0;
      }

      function reset() {
        bgm.pause(); bgm.currentTime = 0;
        sOver.pause(); sOver.currentTime = 0;

        obstacles.length = 0; clouds.length = 0;
        items.length = 0;
        // sau dòng: obstacles.length=0; clouds.length=0;
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }  // 🔴 dừng vòng lặp cũ nếu còn
        exploding = false;            // 🔴 tắt trạng thái nổ
        particles.length = 0;         // 🔴 xóa hạt nổ
        clouds.length = 0;
        letterItems.length = 0;
        collectedLetters.clear();
        amoriCloudUntil = 0;

        for (let i = 0; i < 4; i++) clouds.push({ x: rand(cvs.width, cvs.width * 2), y: rand(20, 120), s: rand(0.3, 0.8) });
        worldSpeed = BASE_SPEED; tick = 0; score = 0; scroll = 0; running = false; gameOver = false; dino.vy = 0;
        // --- WEATHER STATE ---
        let weather = "day";   // day | night | rain
        let stars = [];
        let raindrops = [];
        exploding = false;
        particles.length = 0;

        positionDinoX();
        dino.y = groundYAt(dino.x) - dino.h; dino.onGround = true;
        hidePromo();          // ẩn overlay khi bắt đầu lại
        promoShown = false;   // reset cờ
        showStartUI();     // hiện lại màn hình chờ khi reset

        draw();
        stars.length = 0;
        raindrops.length = 0;
        weather = "day";
      }

      function start() {
        if (!running && !gameOver) {
          hideStartUI();      // ẩn màn hình chờ
          running = true;
          bgm.currentTime = 0;
          bgm.play().catch(() => { });  // có thể bị chặn nếu chưa có thao tác người dùng
          loop();
        }
      }



      function spawnObstacle() {
        const type = Math.random() < 0.6 ? 'cactus' : 'hole';
        if (type === 'cactus') {
          const count = irand(1, 3), parts = []; let totalW = 0;
          for (let i = 0; i < count; i++) { const w = irand(14, 22), h = irand(32, 56); parts.push({ w, h }); totalW += w + 8; }
          obstacles.push({ type, x: cvs.width + 20, parts, w: totalW, passed: false });
        } else {
          const w = irand(38, 70);
          obstacles.push({ type, x: cvs.width + 20, w, passed: false });
        }
      }

      function spawnLetter() {
        // chọn một chữ chưa có, nếu đủ rồi thì random
        const remaining = LETTERS.filter(ch => !collectedLetters.has(ch));
        const ch = (remaining.length ? remaining : LETTERS)[irand(0, (remaining.length ? remaining : LETTERS).length)];

        // kích thước & vị trí “trên trời”
        const size = irand(28, 40);
        const x = cvs.width + 40;
        const gy = groundYAt(x);
        const maxY = Math.min(gy - 120, cvs.height * 0.55);
        const minY = Math.max(40, cvs.height * 0.15);
        const y = irand(minY, Math.max(minY + 1, maxY));

        letterItems.push({ ch, x, y, w: size, h: size });
      }

      function spawnItem() {
        const img = ICONS[irand(0, ICONS.length)];
        const size = irand(28, 40);
        const x = cvs.width + 40;

        // cao trên mặt đất, “trên trời”
        const gy = groundYAt(x);
        const maxY = Math.min(gy - 120, cvs.height * 0.55); // không chạm đất
        const minY = Math.max(40, cvs.height * 0.15);
        const y = irand(minY, Math.max(minY + 1, maxY));

        items.push({ img, x, y, w: size, h: size });
      }

      function loop() {
        if (!running && !exploding) return;
        update();
        draw();
        rafId = requestAnimationFrame(loop);   // lưu id để có thể hủy
      }



      function update() {
        tick++;
        worldSpeed = BASE_SPEED + Math.min(6, Math.floor(score / 120)); // ramp chậm

        scroll += worldSpeed;

        if (tick % irand(80, 140) === 0) spawnObstacle(); // thưa hơn
        if (tick % irand(140, 220) === 0) spawnLetter();
        if (tick % irand(220, 320) === 0) spawnItem();


        // physics dino
        dino.vy += GRAVITY;
        dino.y += dino.vy;
        const feetTarget = groundYAt(dino.x) - dino.h;
        if (dino.y >= feetTarget) { dino.y = feetTarget; dino.vy = 0; dino.onGround = true; }
        else dino.onGround = false;

        // --- COYOTE TIME & JUMP BUFFER ---
        if (dino.onGround) {
          coyoteLeft = COYOTE_TIME_MS;
        } else {
          coyoteLeft = Math.max(0, coyoteLeft - (1000 / 60)); // 60fps approx
        }

        bufferLeft = Math.max(0, bufferLeft - (1000 / 60));

        // Nếu có lệnh nhảy (buffer) và vẫn còn coyote -> nhảy ngay
        if (bufferLeft > 0 && coyoteLeft > 0) {
          doJump();
          bufferLeft = 0;
        }


        // parallax mây
        for (const c of clouds) {
          c.x -= worldSpeed * 0.25 * c.s;
          if (c.x < -60) { c.x = cvs.width + rand(40, 200); c.y = rand(20, 120); }
        }

        // di chuyển chướng ngại vật theo cuộn
        for (const ob of obstacles) { ob.x -= worldSpeed; }
        while (obstacles.length && obstacles[0].x + (obstacles[0].w || 40) < -40) obstacles.shift();
        // di chuyển các icon chữ
        for (const it of letterItems) it.x -= worldSpeed * 0.95;
        while (letterItems.length && letterItems[0].x + letterItems[0].w < -40) letterItems.shift();

        // di chuyển collectibles
        for (const it of items) it.x -= worldSpeed * 0.9; // bay chậm hơn tí cho dễ lượm
        while (items.length && items[0].x + items[0].w < -40) items.shift();


        // điểm
        score++;


        // --- weather cycle ---
        const cycle = score % 1000;  // lặp lại sau 1000 điểm
        if (cycle < 300) {
          weather = "day";
        } else if (cycle < 500) {
          weather = "night";
        } else if (cycle < 1000) {
          weather = "rain";
        }

        updateWeather();
        if (score > hiscore) { hiscore = score; localStorage.setItem('dino_hiscore_v4', hiscore); }


        // --- update explosion ---
        if (exploding) {
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.vy += 0.35;          // trọng lực nhẹ
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
          }
          if (particles.length === 0) {
            exploding = false;
            running = false;
            if (gameOver) showPromo();   // ✅ hiện CTA khi nổ xong
          }
        }
        // nhặt item: +200 điểm
        for (let i = items.length - 1; i >= 0; i--) {
          const it = items[i];
          if (rectsOverlap(dino.x, dino.y, dino.w, dino.h, it.x, it.y, it.w, it.h)) {
            score += 200;
            try { sPickup.currentTime = 0; sPickup.play(); } catch (e) { }
            items.splice(i, 1);
          }
        }
        // ✅ NHẶT CHỮ AMORI
        for (let i = letterItems.length - 1; i >= 0; i--) {
          const it = letterItems[i]; // {ch, x, y, w, h}
          if (rectsOverlap(dino.x, dino.y, dino.w, dino.h, it.x, it.y, it.w, it.h)) {
            collectedLetters.add(it.ch);
            score += 200;
            try { sPickup.currentTime = 0; sPickup.play(); } catch (e) { }
            letterItems.splice(i, 1);

            // nếu đủ A M O R I -> gọi mây chữ to
            if (LETTERS.every(c => collectedLetters.has(c))) {
              amoriCloudUntil = performance.now() + 5000; // 5s
              collectedLetters.clear(); // reset bộ sưu tầm cho vòng kế
            }
          }
        }

        // va chạm
        for (const ob of obstacles) {
          if (!ob.passed && (ob.x + (ob.w || 40)) < dino.x) ob.passed = true;
          if (hitTest(ob)) {
            gameOver = true;
            bgm.pause();
            try { sOver.currentTime = 0; sOver.play(); } catch (e) { }

            if (!exploding) {
              // tâm nổ tại giữa nhân vật
              spawnExplosion(dino.x + dino.w / 2, dino.y + dino.h / 2);
            }
            break;
          }
        }

      }

      // === VA CHẠM ===
      function hitTest(ob) {
        const dx = dino.x, dy = dino.y, dw = dino.w, dh = dino.h;

        if (ob.type === 'cactus') {
          let xCursor = ob.x;
          for (const p of ob.parts) {
            const cx = xCursor;
            const cy = groundYAt(cx) - p.h; // đỉnh cột xương rồng bám mặt đất dốc
            if (rectsOverlap(dx, dy, dw, dh, cx, cy, p.w, p.h)) return true;
            xCursor += p.w + 8;
          }
          return false;
        } else {
          const hx = ob.x, hw = ob.w;
          const hy = groundYAt(hx); // mặt đất tại vị trí hố
          const nearGround = dino.y + dino.h > hy - 4;
          const overlapX = (dx + dw) > hx && dx < (hx + hw);
          return nearGround && overlapX;
        }
      }
      function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
      }

      // === VẼ ===
      function drawGround() {
        // Vẽ dải đất theo đường cong mặt đất
        const bottom = cvs.height;
        ctx.save();
        ctx.fillStyle = '#f5b942';
        ctx.beginPath();
        ctx.moveTo(0, groundYAt(0));
        // lấy mẫu theo bước 8px để mượt
        for (let x = 8; x <= cvs.width; x += 8) {
          ctx.lineTo(x, groundYAt(x));
        }
        ctx.lineTo(cvs.width, bottom);
        ctx.lineTo(0, bottom);
        ctx.closePath();
        ctx.fill();

        // hột cát lấm tấm
        for (let i = 0; i < 50; i++) {
          ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08})`;
          const rx = irand(0, cvs.width);
          const ry = irand(groundYAt(rx) + 6, bottom - 4);
          ctx.fillRect(rx, ry, 2, 2);
        }
        ctx.restore();
      }



      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.5)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }

      function drawCloud(x, y) {
        ctx.save(); ctx.translate(x, y); ctx.globalAlpha = .9; ctx.fillStyle = '#fff';
        blob(0, 0, 18); blob(16, -6, 14); blob(30, 0, 16); blob(10, 6, 12);
        ctx.restore();
      }
      function blob(x, y, r) { ctx.beginPath(); ctx.ellipse(x, y, r * 1.2, r, 0, 0, Math.PI * 2); ctx.fill(); }


      function drawLetterIcon(it) {
        // nền “mây” tròn tròn
        ctx.save();
        ctx.translate(it.x + it.w / 2, it.y + it.h / 2);
        ctx.fillStyle = '#ffffff';
        // vài “bông mây” nhỏ
        for (let i = 0; i < 4; i++) {
          const rx = (Math.random() * 0.4 - 0.2) * it.w;
          const ry = (Math.random() * 0.4 - 0.2) * it.h;
          ctx.beginPath();
          ctx.ellipse(rx, ry, it.w * 0.28, it.h * 0.24, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        // đĩa mây chính
        ctx.beginPath();
        ctx.ellipse(0, 0, it.w * 0.45, it.h * 0.38, 0, 0, Math.PI * 2);
        ctx.fill();

        // chữ ở giữa
        ctx.fillStyle = '#0f172a';
        ctx.font = `bold ${Math.floor(it.h * 0.7)}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(it.ch, 0, 0);
        ctx.restore();
      }

      function drawCloudTextAMORI() {
        const textMain = 'AMORI';
        const textSub = 'Order không suy nghĩ';

        const cx = cvs.width / 2;
        const cy = Math.max(60, cvs.height * 0.22);

        // kích thước chữ theo bề rộng màn hình
        const baseW = Math.min(cvs.width * 0.8, 900);
        const fontMain = Math.max(48, Math.floor(baseW / textMain.length * 0.5));
        const fontSub = Math.round(fontMain * 0.42);     // nhỏ hơn hàng dưới
        const gap = Math.round(fontMain * 0.65);     // khoảng cách giữa 2 dòng

        // --- nền mây lớn (trắng tinh, không ám màu)
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = '#ffffff';
        for (let i = 0; i < 36; i++) {
          const ang = (i / 36) * Math.PI * 2;
          const r = baseW * 0.38 + Math.sin(i) * 6;
          const px = cx + Math.cos(ang) * r * 0.18;
          const py = cy + Math.sin(ang) * r * 0.10;
          ctx.beginPath();
          ctx.ellipse(px, py, baseW * 0.085, fontMain * 0.42, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();

        // ——— dòng 1: AMORI (cam)
        ctx.save();
        ctx.fillStyle = BRAND_ORANGE;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `900 ${fontMain}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;

        // viền mảnh cho rõ trên mưa/đêm
        ctx.lineWidth = Math.max(2, Math.floor(fontMain * 0.05));
        ctx.strokeStyle = 'rgba(15,23,42,.15)';
        ctx.strokeText(textMain, cx, cy);
        ctx.fillText(textMain, cx, cy);
        ctx.restore();

        // ——— dòng 2: đám mây (xanh)
        ctx.save();
        ctx.fillStyle = BRAND_BLUE;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `800 ${fontSub}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
        ctx.fillText(textSub, cx, cy + gap);
        ctx.restore();
      }


      function drawDino() {
        const img = SPRITE;
        // fallback nếu ảnh chưa tải xong
        if (!img.complete || !img.width) {
          ctx.fillStyle = '#6c5ce7';
          ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
          return;
        }
        const scale = Math.min(dino.w / img.width, dino.h / img.height);
        const dw = (img.width * scale) | 0, dh = (img.height * scale) | 0;
        const dx = (dino.x + (dino.w - dw) / 2) | 0;
        const dy = (dino.y + (dino.h - dh)) | 0;

        // bóng chân nhẹ
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(dino.x + dino.w / 2, dino.y + dino.h + 2, Math.max(14, dino.w * 0.35), 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, dx, dy, dw, dh);
      }

      function drawCactus(ob) {
        let xCursor = ob.x;
        for (const p of ob.parts) {
          const cx = xCursor;
          const cy = groundYAt(cx) - p.h;
          // thân
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cactus');
          roundRect(cx, cy, p.w, p.h, 4, ctx.fillStyle);
          // nhánh nhỏ
          ctx.fillStyle = '#13a66a';
          const armH = Math.min(18, p.h * 0.45);
          ctx.fillRect(cx - 6, cy + p.h * 0.4, 6, armH);
          ctx.fillRect(cx + p.w, cy + p.h * 0.25, 6, armH);
          xCursor += p.w + 8;
        }
      }

      function drawHole(ob) {
        const hy = groundYAt(ob.x);
        ctx.save();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--hole');
        ctx.beginPath();
        ctx.ellipse(ob.x + ob.w / 2, hy + 8, ob.w / 2, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = .2; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(ob.x + ob.w / 2, hy + 6, ob.w / 2.3, 6, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      function roundRect(x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
      }

      function drawHUD() {
        ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = 'bold 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.textAlign = 'right';   // căn chữ sang phải
        const margin = 16;
        ctx.fillText(`Điểm: ${String(score).padStart(5, '0')}`, cvs.width - margin, 28);
        ctx.fillText(`Kỷ lục: ${String(hiscore).padStart(5, '0')}`, cvs.width - margin, 50);
        ctx.textAlign = 'left'; // (reset lại để các chữ khác không bị ảnh hưởng)
      }


      function drawLetterProgress() {
        const pad = 10;
        const boxW = 16, boxH = 20; // mỗi “ô” của 1 chữ
        const gap = 5;
        const totalW = LETTERS.length * boxW + (LETTERS.length - 1) * gap;
        const x = 10;
        const y = cvs.height - boxH - 10;

        // khung mờ dưới
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 8, y - 8, totalW + 16, boxH + 16);
        ctx.restore();

        // từng ô chữ
        ctx.font = 'bold 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (let i = 0; i < LETTERS.length; i++) {
          const ch = LETTERS[i];
          const bx = x + i * (boxW + gap);

          const owned = collectedLetters.has(ch);
          // viền & nền ô
          ctx.lineWidth = 2;
          ctx.fillStyle = owned ? '#ffd966' : 'rgba(255,255,255,0.6)';
          ctx.strokeStyle = owned ? '#f59e0b' : '#475569';

          roundRect(bx, y, boxW, boxH, 8, ctx.fillStyle);
          ctx.strokeStyle && ctx.strokeRect(bx, y, boxW, boxH);

          // chữ
          ctx.fillStyle = owned ? '#1f2937' : '#334155';
          ctx.fillText(ch, bx + boxW / 2, y + boxH / 2);
        }
      }


      function drawGameOver() {
        ctx.save(); ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = '700 28px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', cvs.width / 2, cvs.height / 2 - 8);
        ctx.font = '600 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.fillText('Nhấn Space hoặc chạm để chơi lại', cvs.width / 2, cvs.height / 2 + 18);
        ctx.restore();
      }

      function updateWeather() {
        if (weather === "night") {
          // sinh sao
          if (stars.length < 80) {
            stars.push({ x: Math.random() * cvs.width, y: Math.random() * cvs.height * 0.5, r: Math.random() * 2 + 1 });
          }
        } else {
          stars.length = 0;
        }

        if (weather === "rain") {
          // mưa
          if (raindrops.length < 200) {
            raindrops.push({ x: Math.random() * cvs.width, y: -10, vy: 8 + Math.random() * 4 });
          }
          for (let r of raindrops) {
            r.y += r.vy;
            if (r.y > cvs.height) { r.x = Math.random() * cvs.width; r.y = -10; }
          }
        } else {
          raindrops.length = 0;
        }
      }

      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.45)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y); ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }
      function drawItem(it) {
        // nếu ảnh đã sẵn sàng thì vẽ ảnh; else vẽ hình tròn vàng
        if (it.img && it.img.complete && it.img.width) {
          ctx.drawImage(it.img, it.x, it.y, it.w, it.h);
        } else {
          ctx.fillStyle = '#ffd84d';
          ctx.beginPath();
          ctx.arc(it.x + it.w / 2, it.y + it.h / 2, it.w / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }


      function draw() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        // mây
        for (const c of clouds) drawCloud(c.x, c.y);

        // đất dốc
        drawGround();

        // chướng ngại vật
        for (const ob of obstacles) { if (ob.type === 'cactus') drawCactus(ob); else drawHole(ob); }

        // ✅ vẽ các icon chữ AMORI ở đây
        for (const it of letterItems) drawLetterIcon(it);

        // collectibles
        for (const it of items) drawItem(it);


        // dino (ẩn khi đang nổ để có cảm giác tan biến)
        if (!exploding) drawDino();

        // explosion particles
        if (exploding) drawExplosion();

        function drawExplosion() {
          for (const p of particles) {
            const alpha = Math.max(0, p.life / EXPLOSION_LIFE); // mờ dần
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
        // dino
        if (!exploding) drawDino();
        if (exploding) drawExplosion();

        // thời tiết
        drawWeather();     // ✅ thêm dòng này ở đây

        // ✅ vẽ mây chữ AMORI nếu đang kích hoạt
        if (performance.now() < amoriCloudUntil) {
          drawCloudTextAMORI();
        }
        // ✅ khung tiến độ chữ (góc phải)
        drawLetterProgress();
        // HUD
        drawHUD();



        if (gameOver) drawGameOver();
      }

      function doJump() {
        dino.vy = JUMP_VELOCITY;
        dino.onGround = false;
        sJump.currentTime = 0;
        sJump.play().catch(() => { });
      }

      // === ĐIỀU KHIỂN ===
      function jump() {
        start();                  // đảm bảo bắt đầu vòng lặp
        bufferLeft = JUMP_BUFFER_MS;  // ghi nhớ lệnh nhảy
      }



      document.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          if (gameOver) { reset(); start(); } else jump();
        }
        if (e.code === 'KeyR') { reset(); start(); }
      });
      cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        if (gameOver) return; // chờ bấm nút trong CTA
        jump();
      }, { passive: false });


      // === RESPONSIVE ===
      function resizeCanvas() {
 // Với viewport-fit=cover, innerWidth/innerHeight đã là full-bleed
  cvs.width  = window.innerWidth;
  cvs.height = window.innerHeight;

  positionDinoX();
  groundBase = cvs.height * 0.78;
  dino.y = groundYAt(dino.x) - dino.h;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();


    })();
  </script>
</body>

</html>