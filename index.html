<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <!-- Thay d√≤ng meta viewport hi·ªán t·∫°i b·∫±ng d√≤ng n√†y -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <title>Amori Runner ‚Äî Order kh√¥ng suy Nghƒ©</title>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2L0N4MY30Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-2L0N4MY30Y');
  </script>

  <!-- Open Graph cho Facebook -->
  <link rel="icon" type="image/png" href="https://github.com/nhihta/Amori_run/blob/main/imganhzalo.png?raw=true">
  <meta property="og:title" content="Game Amori Runner tr√™n AhaFood.AI" />
  <meta property="og:description" content="Ch∆°i game Amori Runner vui nh·ªôn v√† ƒë·∫∑t m√≥n ngay tr√™n AhaFood.AI!" />
  <meta property="og:image" content="https://github.com/nhihta/Amori_run/blob/main/imganhzalo.png?raw=true" />
  <meta property="og:url" content="https://ahafood.ai/store" />
  <meta property="og:type" content="website" />

  <!-- Zalo Link Preview -->
  <meta name="zalo:image" content="https://github.com/nhihta/Amori_run/blob/main/imganhzalo.png?raw=true" />
  <meta name="zalo:title" content="Game Amori Runner tr√™n AhaFood.AI" />
  <meta name="zalo:description" content="Ch∆°i game Amori Runner vui nh·ªôn v√† ƒë·∫∑t m√≥n ngay tr√™n AhaFood.AI!" />
  <style>
    :root {
      --sky: #b3e5ff;
      --ground: #ffd37d;
      --cactus: #19c37d;
      --hole: #1f2937;
      --accent: #ff6b6b;
      --ui: #0f172a;
        /* Safe-area (iOS notch) */
  --safe-top: env(safe-area-inset-top);
  --safe-right: env(safe-area-inset-right);
  --safe-bottom: env(safe-area-inset-bottom);
  --safe-left: env(safe-area-inset-left);
    }

    html,
    body {
  height: 100dvh;              /* ∆∞u ti√™n dynamic viewport */
  margin: 0;
  overflow: hidden;
  background: linear-gradient(180deg, var(--sky), #d9f6ff 60%);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue";
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none; user-select: none;
  overscroll-behavior: none;
    }

    /* Fallback n·∫øu tr√¨nh duy·ªát ch∆∞a h·ªó tr·ª£ 100dvh */
@supports not (height: 100dvh){
  html, body{ height: 100vh; }
}


   /* Canvas ph·ªß s√°t m√©p thi·∫øt b·ªã (edge-to-edge) */
canvas{
  position: fixed;
  inset: 0;                 /* top/right/bottom/left: 0 */
  width: 100vw;
  height: 100dvh;
  display: block;
  background: linear-gradient(180deg, var(--sky), var(--sky) 70%, var(--ground) 70%, var(--ground));
  touch-action: none;
}
@supports not (height: 100dvh){
  canvas{ height: 100vh; }
}

/* C√°c l·ªõp UI ƒë∆∞·ª£c ‚Äúƒë·ªám‚Äù kh·ªèi v√πng tai th·ªè */
.hint{
  position: fixed;
  top: calc(8px + var(--safe-top));
  left: calc(16px + var(--safe-left));
  right: calc(16px + var(--safe-right));
  text-align: center;
  color: var(--ui);
  font-weight: 600;
  z-index: 10;
}

.credit{
  position: fixed;
  bottom: calc(8px + var(--safe-bottom));
  right: calc(12px + var(--safe-right));
  color: #334155;
  font-size: 12px;
  opacity: .75;
  z-index: 10;
}

/* Gi·∫£m k√≠ch th∆∞·ªõc CTA khi m√†n h√¨nh ngang */
@media (orientation: landscape) {
  #promo .promo-box {
    width: 200px;   /* thay v√¨ 92vmin */
    height: 280px;  /* h·∫° chi·ªÅu cao t·ªïng th·ªÉ */
  }

  #promo img {
    max-height: calc(70vh - 80px); /* ch·ª´a ch·ªó cho n√∫t */
  }

  #promo .promo-btn {
    font-size: 13px;
    margin-top: -5px;
    padding: 6px 14px;
    min-width: 100px;
  }
}


    /* === Promo overlay === */
    #promo.promo-hidden {
      display: none;
    }

    #promo {
  position: fixed;
  inset: 0;
  display: flex; align-items: center; justify-content: center;
  background: rgba(0,0,0,.55);
  z-index: 9999;
  padding:
    max(16px, var(--safe-top))
    max(16px, var(--safe-right))
    max(16px, var(--safe-bottom))
    max(16px, var(--safe-left));
    }

    /* H·ªôp CTA: x·∫øp d·ªçc ·∫£nh + n√∫t */
    #promo .promo-box {
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .35);
      text-align: center;
      overflow: hidden;

      display: flex;
      flex-direction: column;
      align-items: center;

      max-width: min(92vmin, 520px);
      /* theo c·∫°nh ng·∫Øn, gi·ªõi h·∫°n 520px */
      max-height: 90vh;
      /* kh√¥ng v∆∞·ª£t qu√° chi·ªÅu cao m√†n h√¨nh */
    }

    /* ·∫¢nh KH√îNG ƒë∆∞·ª£c chi·∫øm h·∫øt 90vh ‚Äî ch·ª´a ch·ªó cho n√∫t */
    #promo img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      max-height: calc(90vh - 80px);
      /* ‚úÖ ch·ª´a ~80px cho n√∫t + kho·∫£ng c√°ch */
    }

    /* N√∫t n·∫±m d∆∞·ªõi ·∫£nh, nh·ªè g·ªçn v√† n·ªÅn cam */
    #promo .promo-btn {
      margin: 0px 0 16px;
      padding: 5px 16px;
      background: #ff7f32;
      /* cam */
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      border-radius: 8px;
      text-decoration: none;
      box-shadow: 0 4px 12px rgba(255, 127, 50, .35);
      width: auto;
      min-width: 120px;
      /* nh·ªè g·ªçn theo ch·ªØ */
    }

    #promo .promo-btn:active {
      transform: translateY(1px);
    }

    /* T·ªëi ∆∞u th√™m cho d·ªçc */
    @media (orientation:portrait) {
      #promo .promo-box {
        max-height: 88vh;
      }

      #promo img {
        max-height: calc(88vh - 80px);
      }
    }


    /* ph·∫ßn ·∫£nh l√∫c b·∫Øt ƒë·∫ßu */
    /* === START UI (m√†n h√¨nh ch·ªù) === */
    .start-hidden {
      display: none;
    }

    #startUI {
  position: fixed; inset: 0;
  display: flex; align-items:center; justify-content:center;
  z-index: 5000; pointer-events:auto; background: transparent;
  padding:
    max(16px, var(--safe-top))
    max(16px, var(--safe-right))
    max(16px, var(--safe-bottom))
    max(16px, var(--safe-left));
    }

    .start-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    /* ·∫¢nh chi·∫øm ~90% c·∫°nh ng·∫Øn c·ªßa m√†n h√¨nh, t·ª± co theo xoay */
    #startImg {
      width: 90vmin;
      /* 90% c·∫°nh ng·∫Øn c·ªßa viewport (d·ªçc/ ngang ƒë·ªÅu ƒë·∫πp) */
      max-width: 1000px;
      height: auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
    }

    /* Khi m√†n h√¨nh ngang r·ªông ‚Üí cho to h∆°n */
    @media (orientation: landscape) {
      #startImg {
        width: 70vw;
        /* chi·∫øm 70% chi·ªÅu r·ªông m√†n h√¨nh */
        max-width: 1200px;
        /* cho ph√©p r·ªông h∆°n n·∫øu m√†n h√¨nh l·ªõn */
      }
    }

    /* nh√≥m n√∫t */
    .start-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* n√∫t */
    .start-btn {
      appearance: none;
      border: 0;
      cursor: pointer;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, .15);
    }

    /* n√∫t B·∫Øt ƒë·∫ßu (cam) */
    #btnStart {
      background: #ff7a00;
      color: #fff;
    }

    #btnStart:active {
      transform: translateY(1px);
    }

    /* n√∫t T√¨m hi·ªÉu th√™m (vi·ªÅn cam) */
    #btnMore {
      background: #fff;
      color: #ff7a00;
      border: 2px solid #ff7a00;
    }

    .start-hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <canvas id="game" width="900" height="280"></canvas>
  <!-- START UI: hi·ªán khi ch∆∞a b·∫Øt ƒë·∫ßu -->
  <div id="startUI" class="start-hidden">
    <div class="start-box">
      <!-- thay b·∫±ng ·∫£nh c·ªßa b·∫°n; ·∫£nh l·ªõn s·∫Ω t·ª± co v·ªÅ 90vmin -->
      <img id="startImg" src="banner.jpg" alt="AhaFood.AI" />
      <div class="start-actions">
        <button id="btnStart" class="start-btn">B·∫Øt ƒë·∫ßu</button>
        <button id="btnMore" class="start-btn">T√¨m hi·ªÉu th√™m</button>
      </div>
    </div>
  </div>

  <!-- Overlay promo khi game over -->
  <div id="promo" class="promo-hidden">
    <div class="promo-box">
      <img src="CTA.jpg" alt="AhaFood.AI - g·ª£i √Ω m√≥n theo t√¢m tr·∫°ng"><br>
      <a class="promo-btn" href="https://bit.ly/46dGFUs" target="_blank" rel="noopener">
        Th·ª≠ Ngay
      </a>
      <small id="btnRestart" style="color:red; margin-top:-8px; cursor:pointer">
        * Ch·∫°m ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i
      </small>

    </div>

  </div>


  <!-- N√∫t xoay m√†n h√¨nh -->
  <div class="hint" style="font-size: 13px;">Nh·∫•n <span style="color:var(--accent);">Ch·∫°m ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
  <div class="credit">Xoay m√†n h√¨nh ngang ƒë·ªÉ c√≥ tr·∫£i nghi·ªám t·ªët nh·∫•t</div>

  <script>
    (() => {
      const cvs = document.getElementById('game');
      const ctx = cvs.getContext('2d');

      // === BRAND COLORS ===
      const BRAND_ORANGE = '#ff7f32'; // cam AhaFood.AI
      const BRAND_BLUE = '#0d4073'; // xanh AhaFood.AI
      // === √ÇM THANH ===
      const bgm = new Audio('bgm.mp3');   // nh·∫°c n·ªÅn
      bgm.loop = true;
      bgm.volume = 0.5;

      const sJump = new Audio('jump.mp3');  // √¢m thanh nh·∫£y
      sJump.volume = 0.9;

      const sOver = new Audio('over.mp3');  // √¢m thanh thua

      // T·ª± t·∫°m d·ª´ng khi tab b·ªã ·∫©n
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) bgm.pause();
        else if (running && !gameOver) bgm.play().catch(() => { });
      });

      // Promo overlay
      const promoEl = document.getElementById('promo');
      const btnRestart = document.getElementById('btnRestart');
      if (btnRestart) {
        btnRestart.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation(); // kh√¥ng d√≠nh event overlay/CTA
          hidePromo();
          reset();
          start();
        });
      }

      let promoShown = false;
      function showPromo() { if (!promoShown) { promoEl.classList.remove('promo-hidden'); promoShown = true; } }
      function hidePromo() { promoEl.classList.add('promo-hidden'); promoShown = false; }





      // === SPRITE (·∫£nh PNG c·ªßa b·∫°n) ===
      const SPRITE = new Image();
      SPRITE.src = "lasticon.png"; // TODO: ƒë·ªïi th√†nh URL/ƒë∆∞·ªùng d·∫´n ·∫£nh c·ªßa b·∫°n

      // === COLLECTIBLE ICONS ===
      const ICON_SRC = [
        "icons/tea.png",      // tr√† s·ªØa
        "icons/noodles.png",  // t√¥ m√¨
        "icons/coffee.png",   // ly c√† ph√™
        "icons/pizza.png",    // b√°nh pizza
        "icons/chicken-leg.png",
        "icons/rice.png"   // g√† r√°n
      ];
      const ICONS = ICON_SRC.map(src => { const im = new Image(); im.src = src; return im; });

      // (tu·ª≥ ch·ªçn) √¢m thanh nh·∫∑t ƒë·ªì
      const sPickup = new Audio('pickup.mp3');
      sPickup.volume = 0.9;

      // ---- K√çCH TH∆Ø·ªöC DINO (ch·ªâ ƒë·ªïi ·ªü ƒë√¢y) ----


      const DINO_HEIGHT = 84; // ƒë·ªïi s·ªë n√†y ƒë·ªÉ to/nh·ªè
      let DINO_WIDTH = 44;    // s·∫Ω t√≠nh t·ª´ t·ªâ l·ªá ·∫£nh khi ·∫£nh load xong

      function applySpriteSize() {
        const aspect = (SPRITE.width && SPRITE.height) ? SPRITE.width / SPRITE.height : 1;
        DINO_WIDTH = Math.round(DINO_HEIGHT * aspect);
        dino.w = DINO_WIDTH;
        dino.h = DINO_HEIGHT;
        dino.y = groundYAt(dino.x) - dino.h;   // ch√¢n ch·∫°m ƒë·∫•t
      }

      function onSpriteReady() {
        applySpriteSize();
        reset();            // ch·ªâ reset khi ·∫£nh ƒë√£ s·∫µn s√†ng
        draw();             // v·∫Ω l·∫°i m√†n h√¨nh ch·ªù b·∫±ng ·∫£nh th·∫≠t
      }

      SPRITE.onload = onSpriteReady;
      // N·∫øu ·∫£nh ƒë√£ cache s·∫µn (load c·ª±c nhanh) th√¨ g·ªçi lu√¥n:
      if (SPRITE.complete) onSpriteReady();


      // === H·∫∞NG S·ªê ===
      const GRAVITY = 0.62;          // r∆°i ch·∫≠m h∆°n -> d·ªÖ canh
      const JUMP_VELOCITY = -17.5;   // b·∫≠t cao & nh·∫°y h∆°n
      const BASE_SPEED = 4.6;        // t·ªëc ƒë·ªô n·ªÅn ch·∫≠m l·∫°i

      // --- V·ªä TR√ç DINO THEO T·ªà L·ªÜ M√ÄN H√åNH ---
      const DINO_X_RATIO = 0.06;   // 6% b·ªÅ ngang m√†n h√¨nh (ƒë·ªïi s·ªë n·∫øu mu·ªën s√°t/tr√°nh m√©p)
      const DINO_X_MIN = 20;     // kh√¥ng cho s√°t m√©p qu√°

      function positionDinoX() {
        dino.x = Math.max(DINO_X_MIN, Math.round(cvs.width * DINO_X_RATIO));
      }

      // ƒê·ªãa h√¨nh: ƒë∆∞·ªùng c∆° s·ªü dao ƒë·ªông quanh 78% chi·ªÅu cao
      const HILLS = {
        amp1: 21, len1: 700,   // s√≥ng m∆∞·ª£t, chu k·ª≥ d√†i
        amp2: 10, len2: 400    // s√≥ng ph·ª•, chi ti·∫øt nh·ªè
      };

      const startUI = document.getElementById('startUI');
      const btnStart = document.getElementById('btnStart');
      const btnMore = document.getElementById('btnMore');

      function showStartUI() { startUI.classList.remove('start-hidden'); }
      function hideStartUI() { startUI.classList.add('start-hidden'); }

      // click n√∫t
      btnStart.onclick = () => { start(); };


      btnMore.onclick = () => { window.open('https://ahafood.ai/store', '_blank', 'noopener'); };


      // === TR·∫†NG TH√ÅI ===
      let groundBase;                 // y c∆° s·ªü (ph·ª• thu·ªôc k√≠ch th∆∞·ªõc m√†n h√¨nh)
      let scroll = 0;                 // offset cu·ªôn th·∫ø gi·ªõi
      let worldSpeed = BASE_SPEED;
      let tick = 0, score = 0;
      let hiscore = +localStorage.getItem('dino_hiscore_v4') || 0;
      let running = false, gameOver = false;
      // --- WEATHER STATE ---
      let weather = "day";         // day | night | rain
      let stars = [];
      let raindrops = [];

      // === AMORI LETTERS ===
      const LETTERS = ['A', 'M', 'O', 'R', 'I'];
      let letterItems = [];              // c√°c icon ch·ªØ ƒëang bay
      let collectedLetters = new Set();  // c√°c ch·ªØ ƒë√£ nh·∫∑t
      let amoriCloudUntil = 0;           // timestamp ms -> hi·ªán m√¢y "AMORI" ƒë·∫øn khi n√†o




      let rafId = null;
      // Jump leniency
      const COYOTE_TIME_MS = 120;
      const JUMP_BUFFER_MS = 150;

      let coyoteLeft = 0;   // th·ªùi gian c√≤n l·∫°i ƒë∆∞·ª£c ph√©p nh·∫£y sau khi r·ªùi ƒë·∫•t
      let bufferLeft = 0;   // th·ªùi gian c√≤n l·∫°i l·ªánh nh·∫£y ƒë√£ b·∫•m s·ªõm


      //n·ªï
      // --- EXPLOSION STATE ---
      let exploding = false;
      let particles = [];     // c√°c h·∫°t n·ªï
      const EXPLOSION_LIFE = 50;  // s·ªë frame t·ªëi ƒëa m·ªói h·∫°t

      function spawnExplosion(cx, cy) {
        exploding = true;
        particles.length = 0;
        const count = 80; // s·ªë h·∫°t n·ªï
        for (let i = 0; i < count; i++) {
          const ang = Math.random() * Math.PI * 2;
          const spd = 2.5 + Math.random() * 4.5;    // t·ªëc ƒë·ªô ban ƒë·∫ßu
          particles.push({
            x: cx, y: cy,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd - 2,            // h∆°i b·ªëc l√™n
            life: EXPLOSION_LIFE,
            size: 2 + Math.random() * 3,
            color: (i % 3 === 0 ? '#f97316' : i % 3 === 1 ? '#facc15' : '#ef4444') // cam / v√†ng / ƒë·ªè
          });
        }
      }


      const dino = { x: 100, y: 0, vy: 0, w: 44, h: 52, onGround: false };
      dino.h = DINO_HEIGHT;
      dino.w = DINO_WIDTH;

      const obstacles = [], clouds = []; const items = [];
      function rand(a, b) { return Math.random() * (b - a) + a }
      function irand(a, b) { return Math.floor(rand(a, b)) }

      // === ƒê·ªäA H√åNH: y m·∫∑t ƒë·∫•t t·∫°i to·∫° ƒë·ªô m√†n h√¨nh x (c√≥ t√≠nh cu·ªôn) ===
      function groundYAt(screenX) {
        const worldX = scroll + screenX;
        // 2 s√≥ng sin ch·ªìng nhau ƒë·ªÉ t·∫°o d·ªëc m·ªÅm m·∫°i
        const y = groundBase
          + HILLS.amp1 * Math.sin((worldX) / HILLS.len1 * 2 * Math.PI)
          + HILLS.amp2 * Math.sin((worldX) / HILLS.len2 * 2 * Math.PI + 1.2);
        return y | 0;
      }

      function reset() {
        bgm.pause(); bgm.currentTime = 0;
        sOver.pause(); sOver.currentTime = 0;

        obstacles.length = 0; clouds.length = 0;
        items.length = 0;
        // sau d√≤ng: obstacles.length=0; clouds.length=0;
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }  // üî¥ d·ª´ng v√≤ng l·∫∑p c≈© n·∫øu c√≤n
        exploding = false;            // üî¥ t·∫Øt tr·∫°ng th√°i n·ªï
        particles.length = 0;         // üî¥ x√≥a h·∫°t n·ªï
        clouds.length = 0;
        letterItems.length = 0;
        collectedLetters.clear();
        amoriCloudUntil = 0;

        for (let i = 0; i < 4; i++) clouds.push({ x: rand(cvs.width, cvs.width * 2), y: rand(20, 120), s: rand(0.3, 0.8) });
        worldSpeed = BASE_SPEED; tick = 0; score = 0; scroll = 0; running = false; gameOver = false; dino.vy = 0;
        // --- WEATHER STATE ---
        let weather = "day";   // day | night | rain
        let stars = [];
        let raindrops = [];
        exploding = false;
        particles.length = 0;

        positionDinoX();
        dino.y = groundYAt(dino.x) - dino.h; dino.onGround = true;
        hidePromo();          // ·∫©n overlay khi b·∫Øt ƒë·∫ßu l·∫°i
        promoShown = false;   // reset c·ªù
        showStartUI();     // hi·ªán l·∫°i m√†n h√¨nh ch·ªù khi reset

        draw();
        stars.length = 0;
        raindrops.length = 0;
        weather = "day";
      }

      function start() {
        if (!running && !gameOver) {
          hideStartUI();      // ·∫©n m√†n h√¨nh ch·ªù
          running = true;
          bgm.currentTime = 0;
          bgm.play().catch(() => { });  // c√≥ th·ªÉ b·ªã ch·∫∑n n·∫øu ch∆∞a c√≥ thao t√°c ng∆∞·ªùi d√πng
          loop();
        }
      }



      function spawnObstacle() {
        const type = Math.random() < 0.6 ? 'cactus' : 'hole';
        if (type === 'cactus') {
          const count = irand(1, 3), parts = []; let totalW = 0;
          for (let i = 0; i < count; i++) { const w = irand(14, 22), h = irand(32, 56); parts.push({ w, h }); totalW += w + 8; }
          obstacles.push({ type, x: cvs.width + 20, parts, w: totalW, passed: false });
        } else {
          const w = irand(38, 70);
          obstacles.push({ type, x: cvs.width + 20, w, passed: false });
        }
      }

      function spawnLetter() {
        // ch·ªçn m·ªôt ch·ªØ ch∆∞a c√≥, n·∫øu ƒë·ªß r·ªìi th√¨ random
        const remaining = LETTERS.filter(ch => !collectedLetters.has(ch));
        const ch = (remaining.length ? remaining : LETTERS)[irand(0, (remaining.length ? remaining : LETTERS).length)];

        // k√≠ch th∆∞·ªõc & v·ªã tr√≠ ‚Äútr√™n tr·ªùi‚Äù
        const size = irand(28, 40);
        const x = cvs.width + 40;
        const gy = groundYAt(x);
        const maxY = Math.min(gy - 120, cvs.height * 0.55);
        const minY = Math.max(40, cvs.height * 0.15);
        const y = irand(minY, Math.max(minY + 1, maxY));

        letterItems.push({ ch, x, y, w: size, h: size });
      }

      function spawnItem() {
        const img = ICONS[irand(0, ICONS.length)];
        const size = irand(28, 40);
        const x = cvs.width + 40;

        // cao tr√™n m·∫∑t ƒë·∫•t, ‚Äútr√™n tr·ªùi‚Äù
        const gy = groundYAt(x);
        const maxY = Math.min(gy - 120, cvs.height * 0.55); // kh√¥ng ch·∫°m ƒë·∫•t
        const minY = Math.max(40, cvs.height * 0.15);
        const y = irand(minY, Math.max(minY + 1, maxY));

        items.push({ img, x, y, w: size, h: size });
      }

      function loop() {
        if (!running && !exploding) return;
        update();
        draw();
        rafId = requestAnimationFrame(loop);   // l∆∞u id ƒë·ªÉ c√≥ th·ªÉ h·ªßy
      }



      function update() {
        tick++;
        worldSpeed = BASE_SPEED + Math.min(6, Math.floor(score / 120)); // ramp ch·∫≠m

        scroll += worldSpeed;

        if (tick % irand(80, 140) === 0) spawnObstacle(); // th∆∞a h∆°n
        if (tick % irand(140, 220) === 0) spawnLetter();
        if (tick % irand(220, 320) === 0) spawnItem();


        // physics dino
        dino.vy += GRAVITY;
        dino.y += dino.vy;
        const feetTarget = groundYAt(dino.x) - dino.h;
        if (dino.y >= feetTarget) { dino.y = feetTarget; dino.vy = 0; dino.onGround = true; }
        else dino.onGround = false;

        // --- COYOTE TIME & JUMP BUFFER ---
        if (dino.onGround) {
          coyoteLeft = COYOTE_TIME_MS;
        } else {
          coyoteLeft = Math.max(0, coyoteLeft - (1000 / 60)); // 60fps approx
        }

        bufferLeft = Math.max(0, bufferLeft - (1000 / 60));

        // N·∫øu c√≥ l·ªánh nh·∫£y (buffer) v√† v·∫´n c√≤n coyote -> nh·∫£y ngay
        if (bufferLeft > 0 && coyoteLeft > 0) {
          doJump();
          bufferLeft = 0;
        }


        // parallax m√¢y
        for (const c of clouds) {
          c.x -= worldSpeed * 0.25 * c.s;
          if (c.x < -60) { c.x = cvs.width + rand(40, 200); c.y = rand(20, 120); }
        }

        // di chuy·ªÉn ch∆∞·ªõng ng·∫°i v·∫≠t theo cu·ªôn
        for (const ob of obstacles) { ob.x -= worldSpeed; }
        while (obstacles.length && obstacles[0].x + (obstacles[0].w || 40) < -40) obstacles.shift();
        // di chuy·ªÉn c√°c icon ch·ªØ
        for (const it of letterItems) it.x -= worldSpeed * 0.95;
        while (letterItems.length && letterItems[0].x + letterItems[0].w < -40) letterItems.shift();

        // di chuy·ªÉn collectibles
        for (const it of items) it.x -= worldSpeed * 0.9; // bay ch·∫≠m h∆°n t√≠ cho d·ªÖ l∆∞·ª£m
        while (items.length && items[0].x + items[0].w < -40) items.shift();


        // ƒëi·ªÉm
        score++;


        // --- weather cycle ---
        const cycle = score % 1000;  // l·∫∑p l·∫°i sau 1000 ƒëi·ªÉm
        if (cycle < 300) {
          weather = "day";
        } else if (cycle < 500) {
          weather = "night";
        } else if (cycle < 1000) {
          weather = "rain";
        }

        updateWeather();
        if (score > hiscore) { hiscore = score; localStorage.setItem('dino_hiscore_v4', hiscore); }


        // --- update explosion ---
        if (exploding) {
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.vy += 0.35;          // tr·ªçng l·ª±c nh·∫π
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
          }
          if (particles.length === 0) {
            exploding = false;
            running = false;
            if (gameOver) showPromo();   // ‚úÖ hi·ªán CTA khi n·ªï xong
          }
        }
        // nh·∫∑t item: +200 ƒëi·ªÉm
        for (let i = items.length - 1; i >= 0; i--) {
          const it = items[i];
          if (rectsOverlap(dino.x, dino.y, dino.w, dino.h, it.x, it.y, it.w, it.h)) {
            score += 200;
            try { sPickup.currentTime = 0; sPickup.play(); } catch (e) { }
            items.splice(i, 1);
          }
        }
        // ‚úÖ NH·∫∂T CH·ªÆ AMORI
        for (let i = letterItems.length - 1; i >= 0; i--) {
          const it = letterItems[i]; // {ch, x, y, w, h}
          if (rectsOverlap(dino.x, dino.y, dino.w, dino.h, it.x, it.y, it.w, it.h)) {
            collectedLetters.add(it.ch);
            score += 200;
            try { sPickup.currentTime = 0; sPickup.play(); } catch (e) { }
            letterItems.splice(i, 1);

            // n·∫øu ƒë·ªß A M O R I -> g·ªçi m√¢y ch·ªØ to
            if (LETTERS.every(c => collectedLetters.has(c))) {
              amoriCloudUntil = performance.now() + 5000; // 5s
              collectedLetters.clear(); // reset b·ªô s∆∞u t·∫ßm cho v√≤ng k·∫ø
            }
          }
        }

        // va ch·∫°m
        for (const ob of obstacles) {
          if (!ob.passed && (ob.x + (ob.w || 40)) < dino.x) ob.passed = true;
          if (hitTest(ob)) {
            gameOver = true;
            bgm.pause();
            try { sOver.currentTime = 0; sOver.play(); } catch (e) { }

            if (!exploding) {
              // t√¢m n·ªï t·∫°i gi·ªØa nh√¢n v·∫≠t
              spawnExplosion(dino.x + dino.w / 2, dino.y + dino.h / 2);
            }
            break;
          }
        }

      }

      // === VA CH·∫†M ===
      function hitTest(ob) {
        const dx = dino.x, dy = dino.y, dw = dino.w, dh = dino.h;

        if (ob.type === 'cactus') {
          let xCursor = ob.x;
          for (const p of ob.parts) {
            const cx = xCursor;
            const cy = groundYAt(cx) - p.h; // ƒë·ªânh c·ªôt x∆∞∆°ng r·ªìng b√°m m·∫∑t ƒë·∫•t d·ªëc
            if (rectsOverlap(dx, dy, dw, dh, cx, cy, p.w, p.h)) return true;
            xCursor += p.w + 8;
          }
          return false;
        } else {
          const hx = ob.x, hw = ob.w;
          const hy = groundYAt(hx); // m·∫∑t ƒë·∫•t t·∫°i v·ªã tr√≠ h·ªë
          const nearGround = dino.y + dino.h > hy - 4;
          const overlapX = (dx + dw) > hx && dx < (hx + hw);
          return nearGround && overlapX;
        }
      }
      function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
      }

      // === V·∫º ===
      function drawGround() {
        // V·∫Ω d·∫£i ƒë·∫•t theo ƒë∆∞·ªùng cong m·∫∑t ƒë·∫•t
        const bottom = cvs.height;
        ctx.save();
        ctx.fillStyle = '#f5b942';
        ctx.beginPath();
        ctx.moveTo(0, groundYAt(0));
        // l·∫•y m·∫´u theo b∆∞·ªõc 8px ƒë·ªÉ m∆∞·ª£t
        for (let x = 8; x <= cvs.width; x += 8) {
          ctx.lineTo(x, groundYAt(x));
        }
        ctx.lineTo(cvs.width, bottom);
        ctx.lineTo(0, bottom);
        ctx.closePath();
        ctx.fill();

        // h·ªôt c√°t l·∫•m t·∫•m
        for (let i = 0; i < 50; i++) {
          ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08})`;
          const rx = irand(0, cvs.width);
          const ry = irand(groundYAt(rx) + 6, bottom - 4);
          ctx.fillRect(rx, ry, 2, 2);
        }
        ctx.restore();
      }



      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.5)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }

      function drawCloud(x, y) {
        ctx.save(); ctx.translate(x, y); ctx.globalAlpha = .9; ctx.fillStyle = '#fff';
        blob(0, 0, 18); blob(16, -6, 14); blob(30, 0, 16); blob(10, 6, 12);
        ctx.restore();
      }
      function blob(x, y, r) { ctx.beginPath(); ctx.ellipse(x, y, r * 1.2, r, 0, 0, Math.PI * 2); ctx.fill(); }


      function drawLetterIcon(it) {
        // n·ªÅn ‚Äúm√¢y‚Äù tr√≤n tr√≤n
        ctx.save();
        ctx.translate(it.x + it.w / 2, it.y + it.h / 2);
        ctx.fillStyle = '#ffffff';
        // v√†i ‚Äúb√¥ng m√¢y‚Äù nh·ªè
        for (let i = 0; i < 4; i++) {
          const rx = (Math.random() * 0.4 - 0.2) * it.w;
          const ry = (Math.random() * 0.4 - 0.2) * it.h;
          ctx.beginPath();
          ctx.ellipse(rx, ry, it.w * 0.28, it.h * 0.24, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        // ƒëƒ©a m√¢y ch√≠nh
        ctx.beginPath();
        ctx.ellipse(0, 0, it.w * 0.45, it.h * 0.38, 0, 0, Math.PI * 2);
        ctx.fill();

        // ch·ªØ ·ªü gi·ªØa
        ctx.fillStyle = '#0f172a';
        ctx.font = `bold ${Math.floor(it.h * 0.7)}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(it.ch, 0, 0);
        ctx.restore();
      }

      function drawCloudTextAMORI() {
        const textMain = 'AMORI';
        const textSub = 'Order kh√¥ng suy nghƒ©';

        const cx = cvs.width / 2;
        const cy = Math.max(60, cvs.height * 0.22);

        // k√≠ch th∆∞·ªõc ch·ªØ theo b·ªÅ r·ªông m√†n h√¨nh
        const baseW = Math.min(cvs.width * 0.8, 900);
        const fontMain = Math.max(48, Math.floor(baseW / textMain.length * 0.5));
        const fontSub = Math.round(fontMain * 0.42);     // nh·ªè h∆°n h√†ng d∆∞·ªõi
        const gap = Math.round(fontMain * 0.65);     // kho·∫£ng c√°ch gi·ªØa 2 d√≤ng

        // --- n·ªÅn m√¢y l·ªõn (tr·∫Øng tinh, kh√¥ng √°m m√†u)
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = '#ffffff';
        for (let i = 0; i < 36; i++) {
          const ang = (i / 36) * Math.PI * 2;
          const r = baseW * 0.38 + Math.sin(i) * 6;
          const px = cx + Math.cos(ang) * r * 0.18;
          const py = cy + Math.sin(ang) * r * 0.10;
          ctx.beginPath();
          ctx.ellipse(px, py, baseW * 0.085, fontMain * 0.42, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();

        // ‚Äî‚Äî‚Äî d√≤ng 1: AMORI (cam)
        ctx.save();
        ctx.fillStyle = BRAND_ORANGE;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `900 ${fontMain}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;

        // vi·ªÅn m·∫£nh cho r√µ tr√™n m∆∞a/ƒë√™m
        ctx.lineWidth = Math.max(2, Math.floor(fontMain * 0.05));
        ctx.strokeStyle = 'rgba(15,23,42,.15)';
        ctx.strokeText(textMain, cx, cy);
        ctx.fillText(textMain, cx, cy);
        ctx.restore();

        // ‚Äî‚Äî‚Äî d√≤ng 2: ƒë√°m m√¢y (xanh)
        ctx.save();
        ctx.fillStyle = BRAND_BLUE;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `800 ${fontSub}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
        ctx.fillText(textSub, cx, cy + gap);
        ctx.restore();
      }


      function drawDino() {
        const img = SPRITE;
        // fallback n·∫øu ·∫£nh ch∆∞a t·∫£i xong
        if (!img.complete || !img.width) {
          ctx.fillStyle = '#6c5ce7';
          ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
          return;
        }
        const scale = Math.min(dino.w / img.width, dino.h / img.height);
        const dw = (img.width * scale) | 0, dh = (img.height * scale) | 0;
        const dx = (dino.x + (dino.w - dw) / 2) | 0;
        const dy = (dino.y + (dino.h - dh)) | 0;

        // b√≥ng ch√¢n nh·∫π
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(dino.x + dino.w / 2, dino.y + dino.h + 2, Math.max(14, dino.w * 0.35), 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, dx, dy, dw, dh);
      }

      function drawCactus(ob) {
        let xCursor = ob.x;
        for (const p of ob.parts) {
          const cx = xCursor;
          const cy = groundYAt(cx) - p.h;
          // th√¢n
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cactus');
          roundRect(cx, cy, p.w, p.h, 4, ctx.fillStyle);
          // nh√°nh nh·ªè
          ctx.fillStyle = '#13a66a';
          const armH = Math.min(18, p.h * 0.45);
          ctx.fillRect(cx - 6, cy + p.h * 0.4, 6, armH);
          ctx.fillRect(cx + p.w, cy + p.h * 0.25, 6, armH);
          xCursor += p.w + 8;
        }
      }

      function drawHole(ob) {
        const hy = groundYAt(ob.x);
        ctx.save();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--hole');
        ctx.beginPath();
        ctx.ellipse(ob.x + ob.w / 2, hy + 8, ob.w / 2, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = .2; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(ob.x + ob.w / 2, hy + 6, ob.w / 2.3, 6, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      function roundRect(x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
      }

      function drawHUD() {
        ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = 'bold 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.textAlign = 'right';   // cƒÉn ch·ªØ sang ph·∫£i
        const margin = 16;
        ctx.fillText(`ƒêi·ªÉm: ${String(score).padStart(5, '0')}`, cvs.width - margin, 28);
        ctx.fillText(`K·ª∑ l·ª•c: ${String(hiscore).padStart(5, '0')}`, cvs.width - margin, 50);
        ctx.textAlign = 'left'; // (reset l·∫°i ƒë·ªÉ c√°c ch·ªØ kh√°c kh√¥ng b·ªã ·∫£nh h∆∞·ªüng)
      }


      function drawLetterProgress() {
        const pad = 10;
        const boxW = 16, boxH = 20; // m·ªói ‚Äú√¥‚Äù c·ªßa 1 ch·ªØ
        const gap = 5;
        const totalW = LETTERS.length * boxW + (LETTERS.length - 1) * gap;
        const x = 10;
        const y = cvs.height - boxH - 10;

        // khung m·ªù d∆∞·ªõi
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.fillRect(x - 8, y - 8, totalW + 16, boxH + 16);
        ctx.restore();

        // t·ª´ng √¥ ch·ªØ
        ctx.font = 'bold 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (let i = 0; i < LETTERS.length; i++) {
          const ch = LETTERS[i];
          const bx = x + i * (boxW + gap);

          const owned = collectedLetters.has(ch);
          // vi·ªÅn & n·ªÅn √¥
          ctx.lineWidth = 2;
          ctx.fillStyle = owned ? '#ffd966' : 'rgba(255,255,255,0.6)';
          ctx.strokeStyle = owned ? '#f59e0b' : '#475569';

          roundRect(bx, y, boxW, boxH, 8, ctx.fillStyle);
          ctx.strokeStyle && ctx.strokeRect(bx, y, boxW, boxH);

          // ch·ªØ
          ctx.fillStyle = owned ? '#1f2937' : '#334155';
          ctx.fillText(ch, bx + boxW / 2, y + boxH / 2);
        }
      }


      function drawGameOver() {
        ctx.save(); ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = '700 28px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', cvs.width / 2, cvs.height / 2 - 8);
        ctx.font = '600 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.fillText('Nh·∫•n Space ho·∫∑c ch·∫°m ƒë·ªÉ ch∆°i l·∫°i', cvs.width / 2, cvs.height / 2 + 18);
        ctx.restore();
      }

      function updateWeather() {
        if (weather === "night") {
          // sinh sao
          if (stars.length < 80) {
            stars.push({ x: Math.random() * cvs.width, y: Math.random() * cvs.height * 0.5, r: Math.random() * 2 + 1 });
          }
        } else {
          stars.length = 0;
        }

        if (weather === "rain") {
          // m∆∞a
          if (raindrops.length < 200) {
            raindrops.push({ x: Math.random() * cvs.width, y: -10, vy: 8 + Math.random() * 4 });
          }
          for (let r of raindrops) {
            r.y += r.vy;
            if (r.y > cvs.height) { r.x = Math.random() * cvs.width; r.y = -10; }
          }
        } else {
          raindrops.length = 0;
        }
      }

      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.45)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y); ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }
      function drawItem(it) {
        // n·∫øu ·∫£nh ƒë√£ s·∫µn s√†ng th√¨ v·∫Ω ·∫£nh; else v·∫Ω h√¨nh tr√≤n v√†ng
        if (it.img && it.img.complete && it.img.width) {
          ctx.drawImage(it.img, it.x, it.y, it.w, it.h);
        } else {
          ctx.fillStyle = '#ffd84d';
          ctx.beginPath();
          ctx.arc(it.x + it.w / 2, it.y + it.h / 2, it.w / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }


      function draw() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        // m√¢y
        for (const c of clouds) drawCloud(c.x, c.y);

        // ƒë·∫•t d·ªëc
        drawGround();

        // ch∆∞·ªõng ng·∫°i v·∫≠t
        for (const ob of obstacles) { if (ob.type === 'cactus') drawCactus(ob); else drawHole(ob); }

        // ‚úÖ v·∫Ω c√°c icon ch·ªØ AMORI ·ªü ƒë√¢y
        for (const it of letterItems) drawLetterIcon(it);

        // collectibles
        for (const it of items) drawItem(it);


        // dino (·∫©n khi ƒëang n·ªï ƒë·ªÉ c√≥ c·∫£m gi√°c tan bi·∫øn)
        if (!exploding) drawDino();

        // explosion particles
        if (exploding) drawExplosion();

        function drawExplosion() {
          for (const p of particles) {
            const alpha = Math.max(0, p.life / EXPLOSION_LIFE); // m·ªù d·∫ßn
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
        // dino
        if (!exploding) drawDino();
        if (exploding) drawExplosion();

        // th·ªùi ti·∫øt
        drawWeather();     // ‚úÖ th√™m d√≤ng n√†y ·ªü ƒë√¢y

        // ‚úÖ v·∫Ω m√¢y ch·ªØ AMORI n·∫øu ƒëang k√≠ch ho·∫°t
        if (performance.now() < amoriCloudUntil) {
          drawCloudTextAMORI();
        }
        // ‚úÖ khung ti·∫øn ƒë·ªô ch·ªØ (g√≥c ph·∫£i)
        drawLetterProgress();
        // HUD
        drawHUD();



        if (gameOver) drawGameOver();
      }

      function doJump() {
        dino.vy = JUMP_VELOCITY;
        dino.onGround = false;
        sJump.currentTime = 0;
        sJump.play().catch(() => { });
      }

      // === ƒêI·ªÄU KHI·ªÇN ===
      function jump() {
        start();                  // ƒë·∫£m b·∫£o b·∫Øt ƒë·∫ßu v√≤ng l·∫∑p
        bufferLeft = JUMP_BUFFER_MS;  // ghi nh·ªõ l·ªánh nh·∫£y
      }



      document.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          if (gameOver) { reset(); start(); } else jump();
        }
        if (e.code === 'KeyR') { reset(); start(); }
      });
      cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        if (gameOver) return; // ch·ªù b·∫•m n√∫t trong CTA
        jump();
      }, { passive: false });


      // === RESPONSIVE ===
      function resizeCanvas() {
 // V·ªõi viewport-fit=cover, innerWidth/innerHeight ƒë√£ l√† full-bleed
  cvs.width  = window.innerWidth;
  cvs.height = window.innerHeight;

  positionDinoX();
  groundBase = cvs.height * 0.78;
  dino.y = groundYAt(dino.x) - dino.h;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();


    })();
  </script>
</body>

</html>