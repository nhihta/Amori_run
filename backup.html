<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Amori Runner ‚Äî Order kh√¥ng suy Nghƒ©</title>
  <style>
    :root {
      --sky: #b3e5ff;
      --ground: #ffd37d;
      --cactus: #19c37d;
      --hole: #1f2937;
      --accent: #ff6b6b;
      --ui: #0f172a;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(180deg, var(--sky), #d9f6ff 60%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(180deg, var(--sky), var(--sky) 70%, var(--ground) 70%, var(--ground))
    }

    .hint {
      position: fixed;
      top: 10px;
      left: 25px;
      right: 0;
      text-align: center;
      color: var(--ui);
      font-weight: 600;
      z-index: 10
    }

    .credit {
      position: fixed;
      bottom: 8px;
      right: 12px;
      color: #334155;
      font-size: 12px;
      opacity: .75;
      z-index: 10
    }

    /* === Promo overlay === */
    #promo.promo-hidden {
      display: none;
    }

    #promo {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .55);
      z-index: 9999;
      padding: min(4vmin, 16px);
    }

    /* H·ªôp CTA: x·∫øp d·ªçc ·∫£nh + n√∫t */
    #promo .promo-box {
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .35);
      text-align: center;
      overflow: hidden;

      display: flex;
      flex-direction: column;
      align-items: center;

      max-width: min(92vmin, 520px);
      /* theo c·∫°nh ng·∫Øn, gi·ªõi h·∫°n 520px */
      max-height: 90vh;
      /* kh√¥ng v∆∞·ª£t qu√° chi·ªÅu cao m√†n h√¨nh */
    }

    /* ·∫¢nh KH√îNG ƒë∆∞·ª£c chi·∫øm h·∫øt 90vh ‚Äî ch·ª´a ch·ªó cho n√∫t */
    #promo img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      max-height: calc(90vh - 80px);
      /* ‚úÖ ch·ª´a ~80px cho n√∫t + kho·∫£ng c√°ch */
    }

    /* N√∫t n·∫±m d∆∞·ªõi ·∫£nh, nh·ªè g·ªçn v√† n·ªÅn cam */
    #promo .promo-btn {
      margin: 0px 0 16px;
      padding: 5px 16px;
      background: #ff7f32;
      /* cam */
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      border-radius: 8px;
      text-decoration: none;
      box-shadow: 0 4px 12px rgba(255, 127, 50, .35);
      width: auto;
      min-width: 120px;
      /* nh·ªè g·ªçn theo ch·ªØ */
    }

    #promo .promo-btn:active {
      transform: translateY(1px);
    }

    /* T·ªëi ∆∞u th√™m cho d·ªçc */
    @media (orientation:portrait) {
      #promo .promo-box {
        max-height: 88vh;
      }

      #promo img {
        max-height: calc(88vh - 80px);
      }
    }


    /* ph·∫ßn ·∫£nh l√∫c b·∫Øt ƒë·∫ßu */
    /* === START UI (m√†n h√¨nh ch·ªù) === */
    .start-hidden {
      display: none;
    }

    #startUI {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5000;
      /* n·ªïi tr√™n canvas */
      pointer-events: auto;
      background: transparent;
      /* kh√¥ng ph·ªß m·ªù, ch·ªâ hi·ªán n·ªôi dung */
      padding: 16px;
    }

    .start-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    /* ·∫¢nh chi·∫øm ~90% c·∫°nh ng·∫Øn c·ªßa m√†n h√¨nh, t·ª± co theo xoay */
    #startImg {
      width: 90vmin;
      /* 90% c·∫°nh ng·∫Øn c·ªßa viewport (d·ªçc/ ngang ƒë·ªÅu ƒë·∫πp) */
      max-width: 1000px;
      height: auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
    }

    /* Khi m√†n h√¨nh ngang r·ªông ‚Üí cho to h∆°n */
@media (orientation: landscape) {
  #startImg {
    width: 70vw;   /* chi·∫øm 70% chi·ªÅu r·ªông m√†n h√¨nh */
    max-width: 1200px; /* cho ph√©p r·ªông h∆°n n·∫øu m√†n h√¨nh l·ªõn */
  }
}

    /* nh√≥m n√∫t */
    .start-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* n√∫t */
    .start-btn {
      appearance: none;
      border: 0;
      cursor: pointer;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, .15);
    }

    /* n√∫t B·∫Øt ƒë·∫ßu (cam) */
    #btnStart {
      background: #ff7a00;
      color: #fff;
    }

    #btnStart:active {
      transform: translateY(1px);
    }

    /* n√∫t T√¨m hi·ªÉu th√™m (vi·ªÅn cam) */
    #btnMore {
      background: #fff;
      color: #ff7a00;
      border: 2px solid #ff7a00;
    }

    .start-hidden { display: none !important; }

  </style>
</head>

<body>
  <canvas id="game" width="900" height="280"></canvas>
  <!-- START UI: hi·ªán khi ch∆∞a b·∫Øt ƒë·∫ßu -->
  <div id="startUI" class="start-hidden">
    <div class="start-box">
      <!-- thay b·∫±ng ·∫£nh c·ªßa b·∫°n; ·∫£nh l·ªõn s·∫Ω t·ª± co v·ªÅ 90vmin -->
      <img id="startImg"
        src="banner.jpg"
        alt="AhaFood.Ai" />
      <div class="start-actions">
        <button id="btnStart" class="start-btn">B·∫Øt ƒë·∫ßu</button>
        <button id="btnMore" class="start-btn">T√¨m hi·ªÉu th√™m</button>
      </div>
    </div>
  </div>

  <!-- Overlay promo khi game over -->
  <div id="promo" class="promo-hidden">
    <div class="promo-box">
      <img src="CTA.jpg" alt="AhaFood.Ai - g·ª£i √Ω m√≥n theo t√¢m tr·∫°ng"><br>
      <a class="promo-btn" href="https://ahafood.ai/store" target="_blank" rel="noopener">
        Th·ª≠ Ngay
      </a>
      <small style="color: red; margin-top: -8px;"> * Ch·∫°m ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i</small> 
    </div>
    
  </div>
  

  <!-- N√∫t xoay m√†n h√¨nh -->
  <div class="hint">Nh·∫•n <span style="color:var(--accent)">Ch·∫°m ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
  <div class="credit">Xoay m√†n h√¨nh ngang ƒë·ªÉ c√≥ tr·∫£i nghi·ªám t·ªët nh·∫•t</div>

  <script>
    (() => {
      const cvs = document.getElementById('game');
      const ctx = cvs.getContext('2d');
      // Promo overlay
      const promoEl = document.getElementById('promo');
      let promoShown = false;
      function showPromo() { if (!promoShown) { promoEl.classList.remove('promo-hidden'); promoShown = true; } }
      function hidePromo() { promoEl.classList.add('promo-hidden'); promoShown = false; }


      // === SPRITE (·∫£nh PNG c·ªßa b·∫°n) ===
      const SPRITE = new Image();
      SPRITE.src = "dino_s.png"; // TODO: ƒë·ªïi th√†nh URL/ƒë∆∞·ªùng d·∫´n ·∫£nh c·ªßa b·∫°n
      // ---- K√çCH TH∆Ø·ªöC DINO (ch·ªâ ƒë·ªïi ·ªü ƒë√¢y) ----


      const DINO_HEIGHT = 84; // ƒë·ªïi s·ªë n√†y ƒë·ªÉ to/nh·ªè
      let DINO_WIDTH = 44;    // s·∫Ω t√≠nh t·ª´ t·ªâ l·ªá ·∫£nh khi ·∫£nh load xong

      function applySpriteSize() {
        const aspect = (SPRITE.width && SPRITE.height) ? SPRITE.width / SPRITE.height : 1;
        DINO_WIDTH = Math.round(DINO_HEIGHT * aspect);
        dino.w = DINO_WIDTH;
        dino.h = DINO_HEIGHT;
        dino.y = groundYAt(dino.x) - dino.h;   // ch√¢n ch·∫°m ƒë·∫•t
      }

      function onSpriteReady() {
        applySpriteSize();
        reset();            // ch·ªâ reset khi ·∫£nh ƒë√£ s·∫µn s√†ng
        draw();             // v·∫Ω l·∫°i m√†n h√¨nh ch·ªù b·∫±ng ·∫£nh th·∫≠t
      }

      SPRITE.onload = onSpriteReady;
      // N·∫øu ·∫£nh ƒë√£ cache s·∫µn (load c·ª±c nhanh) th√¨ g·ªçi lu√¥n:
      if (SPRITE.complete) onSpriteReady();


      // === H·∫∞NG S·ªê ===
      const GRAVITY = 0.7;
      const JUMP_VELOCITY = -15.5;
      const BASE_SPEED = 6;
      // --- V·ªä TR√ç DINO THEO T·ªà L·ªÜ M√ÄN H√åNH ---
      const DINO_X_RATIO = 0.06;   // 6% b·ªÅ ngang m√†n h√¨nh (ƒë·ªïi s·ªë n·∫øu mu·ªën s√°t/tr√°nh m√©p)
      const DINO_X_MIN = 20;     // kh√¥ng cho s√°t m√©p qu√°

      function positionDinoX() {
        dino.x = Math.max(DINO_X_MIN, Math.round(cvs.width * DINO_X_RATIO));
      }

      // ƒê·ªãa h√¨nh: ƒë∆∞·ªùng c∆° s·ªü dao ƒë·ªông quanh 78% chi·ªÅu cao
      const HILLS = {
        amp1: 21, len1: 700,   // s√≥ng m∆∞·ª£t, chu k·ª≥ d√†i
        amp2: 10, len2: 400    // s√≥ng ph·ª•, chi ti·∫øt nh·ªè
      };

      const startUI = document.getElementById('startUI');
      const btnStart = document.getElementById('btnStart');
      const btnMore = document.getElementById('btnMore');

      function showStartUI() { startUI.classList.remove('start-hidden'); }
      function hideStartUI() { startUI.classList.add('start-hidden'); }

      // click n√∫t
      btnStart.onclick = () => { startUI.classList.add('start-hidden'); };

      btnMore.onclick = () => { window.open('https://ahafood.ai/store', '_blank', 'noopener'); };


      // === TR·∫†NG TH√ÅI ===
      let groundBase;                 // y c∆° s·ªü (ph·ª• thu·ªôc k√≠ch th∆∞·ªõc m√†n h√¨nh)
      let scroll = 0;                 // offset cu·ªôn th·∫ø gi·ªõi
      let worldSpeed = BASE_SPEED;
      let tick = 0, score = 0;
      let hiscore = +localStorage.getItem('dino_hiscore_v4') || 0;
      let running = false, gameOver = false;
      // --- WEATHER STATE ---
      let weather = "day";         // day | night | rain
      let stars = [];
      let raindrops = [];

      let rafId = null;

      //n·ªï
      // --- EXPLOSION STATE ---
      let exploding = false;
      let particles = [];     // c√°c h·∫°t n·ªï
      const EXPLOSION_LIFE = 50;  // s·ªë frame t·ªëi ƒëa m·ªói h·∫°t

      function spawnExplosion(cx, cy) {
        exploding = true;
        particles.length = 0;
        const count = 80; // s·ªë h·∫°t n·ªï
        for (let i = 0; i < count; i++) {
          const ang = Math.random() * Math.PI * 2;
          const spd = 2.5 + Math.random() * 4.5;    // t·ªëc ƒë·ªô ban ƒë·∫ßu
          particles.push({
            x: cx, y: cy,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd - 2,            // h∆°i b·ªëc l√™n
            life: EXPLOSION_LIFE,
            size: 2 + Math.random() * 3,
            color: (i % 3 === 0 ? '#f97316' : i % 3 === 1 ? '#facc15' : '#ef4444') // cam / v√†ng / ƒë·ªè
          });
        }
      }


      const dino = { x: 100, y: 0, vy: 0, w: 44, h: 52, onGround: false };
      dino.h = DINO_HEIGHT;
      dino.w = DINO_WIDTH;

      const obstacles = [], clouds = [];
      function rand(a, b) { return Math.random() * (b - a) + a }
      function irand(a, b) { return Math.floor(rand(a, b)) }

      // === ƒê·ªäA H√åNH: y m·∫∑t ƒë·∫•t t·∫°i to·∫° ƒë·ªô m√†n h√¨nh x (c√≥ t√≠nh cu·ªôn) ===
      function groundYAt(screenX) {
        const worldX = scroll + screenX;
        // 2 s√≥ng sin ch·ªìng nhau ƒë·ªÉ t·∫°o d·ªëc m·ªÅm m·∫°i
        const y = groundBase
          + HILLS.amp1 * Math.sin((worldX) / HILLS.len1 * 2 * Math.PI)
          + HILLS.amp2 * Math.sin((worldX) / HILLS.len2 * 2 * Math.PI + 1.2);
        return y | 0;
      }

      function reset() {
        obstacles.length = 0; clouds.length = 0;
        // sau d√≤ng: obstacles.length=0; clouds.length=0;
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }  // üî¥ d·ª´ng v√≤ng l·∫∑p c≈© n·∫øu c√≤n
        exploding = false;            // üî¥ t·∫Øt tr·∫°ng th√°i n·ªï
        particles.length = 0;         // üî¥ x√≥a h·∫°t n·ªï

        for (let i = 0; i < 4; i++) clouds.push({ x: rand(cvs.width, cvs.width * 2), y: rand(20, 120), s: rand(0.3, 0.8) });
        worldSpeed = BASE_SPEED; tick = 0; score = 0; scroll = 0; running = false; gameOver = false; dino.vy = 0;
        // --- WEATHER STATE ---
        let weather = "day";   // day | night | rain
        let stars = [];
        let raindrops = [];
        exploding = false;
        particles.length = 0;

        positionDinoX();
        dino.y = groundYAt(dino.x) - dino.h; dino.onGround = true;
        hidePromo();          // ·∫©n overlay khi b·∫Øt ƒë·∫ßu l·∫°i
        promoShown = false;   // reset c·ªù
        showStartUI();     // hi·ªán l·∫°i m√†n h√¨nh ch·ªù khi reset

        draw();
        stars.length = 0;
        raindrops.length = 0;
        weather = "day";
      }

      function start() {
        if (!running && !gameOver) {
          hideStartUI();   // ·∫©n m√†n h√¨nh ch·ªù
          running = true;  // (ph·∫ßn c√≤n l·∫°i gi·ªØ nguy√™n)
          loop();
        }
      }


      function spawnObstacle() {
        const type = Math.random() < 0.6 ? 'cactus' : 'hole';
        if (type === 'cactus') {
          const count = irand(1, 4), parts = []; let totalW = 0;
          for (let i = 0; i < count; i++) { const w = irand(14, 24), h = irand(36, 64); parts.push({ w, h }); totalW += w + 8; }
          obstacles.push({ type, x: cvs.width + 20, parts, w: totalW, passed: false });
        } else {
          const w = irand(46, 95);
          obstacles.push({ type, x: cvs.width + 20, w, passed: false });
        }
      }

      function loop() {
        if (!running && !exploding) return;
        update();
        draw();
        rafId = requestAnimationFrame(loop);   // l∆∞u id ƒë·ªÉ c√≥ th·ªÉ h·ªßy
      }



      function update() {
        tick++;
        worldSpeed = BASE_SPEED + Math.min(6, Math.floor(score / 150));
        scroll += worldSpeed;

        if (tick % irand(70, 110) === 0) spawnObstacle();

        // physics dino
        dino.vy += GRAVITY;
        dino.y += dino.vy;
        const feetTarget = groundYAt(dino.x) - dino.h;
        if (dino.y >= feetTarget) { dino.y = feetTarget; dino.vy = 0; dino.onGround = true; }
        else dino.onGround = false;

        // parallax m√¢y
        for (const c of clouds) {
          c.x -= worldSpeed * 0.25 * c.s;
          if (c.x < -60) { c.x = cvs.width + rand(40, 200); c.y = rand(20, 120); }
        }

        // di chuy·ªÉn ch∆∞·ªõng ng·∫°i v·∫≠t theo cu·ªôn
        for (const ob of obstacles) { ob.x -= worldSpeed; }
        while (obstacles.length && obstacles[0].x + (obstacles[0].w || 40) < -40) obstacles.shift();

        // ƒëi·ªÉm
        score++;


        // --- weather cycle ---
        const cycle = score % 1000;  // l·∫∑p l·∫°i sau 1000 ƒëi·ªÉm
        if (cycle < 300) {
          weather = "day";
        } else if (cycle < 500) {
          weather = "night";
        } else if (cycle < 1000) {
          weather = "rain";
        }

        updateWeather();
        if (score > hiscore) { hiscore = score; localStorage.setItem('dino_hiscore_v4', hiscore); }


        // --- update explosion ---
        if (exploding) {
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.vy += 0.35;          // tr·ªçng l·ª±c nh·∫π
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
          }
          if (particles.length === 0) {
            exploding = false;
            running = false;
            if (gameOver) showPromo();   // ‚úÖ hi·ªán CTA khi n·ªï xong
          }
        }
        // va ch·∫°m
        for (const ob of obstacles) {
          if (!ob.passed && (ob.x + (ob.w || 40)) < dino.x) ob.passed = true;
          if (hitTest(ob)) {
            gameOver = true;
            if (!exploding) {
              // t√¢m n·ªï t·∫°i gi·ªØa nh√¢n v·∫≠t
              spawnExplosion(dino.x + dino.w / 2, dino.y + dino.h / 2);
            }
            break;
          }
        }

      }

      // === VA CH·∫†M ===
      function hitTest(ob) {
        const dx = dino.x, dy = dino.y, dw = dino.w, dh = dino.h;

        if (ob.type === 'cactus') {
          let xCursor = ob.x;
          for (const p of ob.parts) {
            const cx = xCursor;
            const cy = groundYAt(cx) - p.h; // ƒë·ªânh c·ªôt x∆∞∆°ng r·ªìng b√°m m·∫∑t ƒë·∫•t d·ªëc
            if (rectsOverlap(dx, dy, dw, dh, cx, cy, p.w, p.h)) return true;
            xCursor += p.w + 8;
          }
          return false;
        } else {
          const hx = ob.x, hw = ob.w;
          const hy = groundYAt(hx); // m·∫∑t ƒë·∫•t t·∫°i v·ªã tr√≠ h·ªë
          const nearGround = dino.y + dino.h > hy - 4;
          const overlapX = (dx + dw) > hx && dx < (hx + hw);
          return nearGround && overlapX;
        }
      }
      function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
      }

      // === V·∫º ===
      function drawGround() {
        // V·∫Ω d·∫£i ƒë·∫•t theo ƒë∆∞·ªùng cong m·∫∑t ƒë·∫•t
        const bottom = cvs.height;
        ctx.save();
        ctx.fillStyle = '#f5b942';
        ctx.beginPath();
        ctx.moveTo(0, groundYAt(0));
        // l·∫•y m·∫´u theo b∆∞·ªõc 8px ƒë·ªÉ m∆∞·ª£t
        for (let x = 8; x <= cvs.width; x += 8) {
          ctx.lineTo(x, groundYAt(x));
        }
        ctx.lineTo(cvs.width, bottom);
        ctx.lineTo(0, bottom);
        ctx.closePath();
        ctx.fill();

        // h·ªôt c√°t l·∫•m t·∫•m
        for (let i = 0; i < 50; i++) {
          ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08})`;
          const rx = irand(0, cvs.width);
          const ry = irand(groundYAt(rx) + 6, bottom - 4);
          ctx.fillRect(rx, ry, 2, 2);
        }
        ctx.restore();
      }



      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.5)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }

      function drawCloud(x, y) {
        ctx.save(); ctx.translate(x, y); ctx.globalAlpha = .9; ctx.fillStyle = '#fff';
        blob(0, 0, 18); blob(16, -6, 14); blob(30, 0, 16); blob(10, 6, 12);
        ctx.restore();
      }
      function blob(x, y, r) { ctx.beginPath(); ctx.ellipse(x, y, r * 1.2, r, 0, 0, Math.PI * 2); ctx.fill(); }

      function drawDino() {
        const img = SPRITE;
        // fallback n·∫øu ·∫£nh ch∆∞a t·∫£i xong
        if (!img.complete || !img.width) {
          ctx.fillStyle = '#6c5ce7';
          ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
          return;
        }
        const scale = Math.min(dino.w / img.width, dino.h / img.height);
        const dw = (img.width * scale) | 0, dh = (img.height * scale) | 0;
        const dx = (dino.x + (dino.w - dw) / 2) | 0;
        const dy = (dino.y + (dino.h - dh)) | 0;

        // b√≥ng ch√¢n nh·∫π
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(dino.x + dino.w / 2, dino.y + dino.h + 2, Math.max(14, dino.w * 0.35), 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, dx, dy, dw, dh);
      }

      function drawCactus(ob) {
        let xCursor = ob.x;
        for (const p of ob.parts) {
          const cx = xCursor;
          const cy = groundYAt(cx) - p.h;
          // th√¢n
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cactus');
          roundRect(cx, cy, p.w, p.h, 4, ctx.fillStyle);
          // nh√°nh nh·ªè
          ctx.fillStyle = '#13a66a';
          const armH = Math.min(18, p.h * 0.45);
          ctx.fillRect(cx - 6, cy + p.h * 0.4, 6, armH);
          ctx.fillRect(cx + p.w, cy + p.h * 0.25, 6, armH);
          xCursor += p.w + 8;
        }
      }

      function drawHole(ob) {
        const hy = groundYAt(ob.x);
        ctx.save();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--hole');
        ctx.beginPath();
        ctx.ellipse(ob.x + ob.w / 2, hy + 8, ob.w / 2, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = .2; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(ob.x + ob.w / 2, hy + 6, ob.w / 2.3, 6, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      function roundRect(x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
      }

      function drawHUD() {
        ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = 'bold 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.fillText(`ƒêi·ªÉm: ${String(score).padStart(5, '0')}`, 16, 28);
        ctx.fillText(`K·ª∑ l·ª•c: ${String(hiscore).padStart(5, '0')}`, 16, 50);
      }

      function drawGameOver() {
        ctx.save(); ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = '700 28px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', cvs.width / 2, cvs.height / 2 - 8);
        ctx.font = '600 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.fillText('Nh·∫•n Space ho·∫∑c ch·∫°m ƒë·ªÉ ch∆°i l·∫°i', cvs.width / 2, cvs.height / 2 + 18);
        ctx.restore();
      }

      function updateWeather() {
        if (weather === "night") {
          // sinh sao
          if (stars.length < 80) {
            stars.push({ x: Math.random() * cvs.width, y: Math.random() * cvs.height * 0.5, r: Math.random() * 2 + 1 });
          }
        } else {
          stars.length = 0;
        }

        if (weather === "rain") {
          // m∆∞a
          if (raindrops.length < 200) {
            raindrops.push({ x: Math.random() * cvs.width, y: -10, vy: 8 + Math.random() * 4 });
          }
          for (let r of raindrops) {
            r.y += r.vy;
            if (r.y > cvs.height) { r.x = Math.random() * cvs.width; r.y = -10; }
          }
        } else {
          raindrops.length = 0;
        }
      }

      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.45)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y); ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }


      function draw() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        // m√¢y
        for (const c of clouds) drawCloud(c.x, c.y);

        // ƒë·∫•t d·ªëc
        drawGround();

        // ch∆∞·ªõng ng·∫°i v·∫≠t
        for (const ob of obstacles) { if (ob.type === 'cactus') drawCactus(ob); else drawHole(ob); }

        // dino (·∫©n khi ƒëang n·ªï ƒë·ªÉ c√≥ c·∫£m gi√°c tan bi·∫øn)
        if (!exploding) drawDino();

        // explosion particles
        if (exploding) drawExplosion();

        function drawExplosion() {
          for (const p of particles) {
            const alpha = Math.max(0, p.life / EXPLOSION_LIFE); // m·ªù d·∫ßn
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
        // dino
        if (!exploding) drawDino();
        if (exploding) drawExplosion();

        // th·ªùi ti·∫øt
        drawWeather();     // ‚úÖ th√™m d√≤ng n√†y ·ªü ƒë√¢y



        // HUD
        drawHUD();

        if (!running && !gameOver) {
          if (coverReady) {
            const iconSize = 120; // 120x120
            const x = (cvs.width - iconSize) / 2;
            const y = (cvs.height - iconSize) / 2;
            ctx.drawImage(COVER, x, y, iconSize, iconSize);
          }
        }

        if (gameOver) drawGameOver();
      }

      // === ƒêI·ªÄU KHI·ªÇN ===
      function jump() { start(); if (dino.onGround) { dino.vy = JUMP_VELOCITY; dino.onGround = false; } }

      document.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          if (gameOver) { reset(); start(); } else jump();
        }
        if (e.code === 'KeyR') { reset(); start(); }
      });
      cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        if (gameOver) { reset(); start(); return; }
        jump();
      }, { passive: false });

      // === RESPONSIVE ===
      function resizeCanvas() {
        cvs.width = window.innerWidth;
        cvs.height = window.innerHeight;
        positionDinoX();
        groundBase = cvs.height * 0.78;
        dino.y = groundYAt(dino.x) - dino.h;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();


    })();
  </script>
</body>

</html>