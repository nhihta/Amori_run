<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Amori Runner — Order không suy Nghĩ</title>
  <style>
    :root {
      --sky: #b3e5ff;
      --ground: #ffd37d;
      --cactus: #19c37d;
      --hole: #1f2937;
      --accent: #ff6b6b;
      --ui: #0f172a;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(180deg, var(--sky), #d9f6ff 60%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(180deg, var(--sky), var(--sky) 70%, var(--ground) 70%, var(--ground))
    }

    .hint {
      position: fixed;
      top: 10px;
      left: 25px;
      right: 0;
      text-align: center;
      color: var(--ui);
      font-weight: 600;
      z-index: 10
    }

    .credit {
      position: fixed;
      bottom: 8px;
      right: 12px;
      color: #334155;
      font-size: 12px;
      opacity: .75;
      z-index: 10
    }

    /* === Promo overlay === */
    #promo.promo-hidden {
      display: none;
    }

    #promo {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .55);
      z-index: 9999;
      padding: min(4vmin, 16px);
    }

    /* Hộp CTA: xếp dọc ảnh + nút */
    #promo .promo-box {
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .35);
      text-align: center;
      overflow: hidden;

      display: flex;
      flex-direction: column;
      align-items: center;

      max-width: min(92vmin, 520px);
      /* theo cạnh ngắn, giới hạn 520px */
      max-height: 90vh;
      /* không vượt quá chiều cao màn hình */
    }

    /* Ảnh KHÔNG được chiếm hết 90vh — chừa chỗ cho nút */
    #promo img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      max-height: calc(90vh - 80px);
      /* ✅ chừa ~80px cho nút + khoảng cách */
    }

    /* Nút nằm dưới ảnh, nhỏ gọn và nền cam */
    #promo .promo-btn {
      margin: 0px 0 16px;
      padding: 5px 16px;
      background: #ff7f32;
      /* cam */
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      border-radius: 8px;
      text-decoration: none;
      box-shadow: 0 4px 12px rgba(255, 127, 50, .35);
      width: auto;
      min-width: 120px;
      /* nhỏ gọn theo chữ */
    }

    #promo .promo-btn:active {
      transform: translateY(1px);
    }

    /* Tối ưu thêm cho dọc */
    @media (orientation:portrait) {
      #promo .promo-box {
        max-height: 88vh;
      }

      #promo img {
        max-height: calc(88vh - 80px);
      }
    }


    /* phần ảnh lúc bắt đầu */
    /* === START UI (màn hình chờ) === */
    .start-hidden {
      display: none;
    }

    #startUI {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5000;
      /* nổi trên canvas */
      pointer-events: auto;
      background: transparent;
      /* không phủ mờ, chỉ hiện nội dung */
      padding: 16px;
    }

    .start-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    /* Ảnh chiếm ~90% cạnh ngắn của màn hình, tự co theo xoay */
    #startImg {
      width: 90vmin;
      /* 90% cạnh ngắn của viewport (dọc/ ngang đều đẹp) */
      max-width: 1000px;
      height: auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
    }

    /* Khi màn hình ngang rộng → cho to hơn */
@media (orientation: landscape) {
  #startImg {
    width: 70vw;   /* chiếm 70% chiều rộng màn hình */
    max-width: 1200px; /* cho phép rộng hơn nếu màn hình lớn */
  }
}

    /* nhóm nút */
    .start-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* nút */
    .start-btn {
      appearance: none;
      border: 0;
      cursor: pointer;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, .15);
    }

    /* nút Bắt đầu (cam) */
    #btnStart {
      background: #ff7a00;
      color: #fff;
    }

    #btnStart:active {
      transform: translateY(1px);
    }

    /* nút Tìm hiểu thêm (viền cam) */
    #btnMore {
      background: #fff;
      color: #ff7a00;
      border: 2px solid #ff7a00;
    }

    .start-hidden { display: none !important; }

  </style>
</head>

<body>
  <canvas id="game" width="900" height="280"></canvas>
  <!-- START UI: hiện khi chưa bắt đầu -->
  <div id="startUI" class="start-hidden">
    <div class="start-box">
      <!-- thay bằng ảnh của bạn; ảnh lớn sẽ tự co về 90vmin -->
      <img id="startImg"
        src="banner.jpg"
        alt="AhaFood.Ai" />
      <div class="start-actions">
        <button id="btnStart" class="start-btn">Bắt đầu</button>
        <button id="btnMore" class="start-btn">Tìm hiểu thêm</button>
      </div>
    </div>
  </div>

  <!-- Overlay promo khi game over -->
  <div id="promo" class="promo-hidden">
    <div class="promo-box">
      <img src="CTA.jpg" alt="AhaFood.Ai - gợi ý món theo tâm trạng"><br>
      <a class="promo-btn" href="https://ahafood.ai/store" target="_blank" rel="noopener">
        Thử Ngay
      </a>
      <small style="color: red; margin-top: -8px;"> * Chạm để bắt đầu lại</small> 
    </div>
    
  </div>
  

  <!-- Nút xoay màn hình -->
  <div class="hint">Nhấn <span style="color:var(--accent)">Chạm để bắt đầu</div>
  <div class="credit">Xoay màn hình ngang để có trải nghiệm tốt nhất</div>

  <script>
    (() => {
      const cvs = document.getElementById('game');
      const ctx = cvs.getContext('2d');
      // Promo overlay
      const promoEl = document.getElementById('promo');
      let promoShown = false;
      function showPromo() { if (!promoShown) { promoEl.classList.remove('promo-hidden'); promoShown = true; } }
      function hidePromo() { promoEl.classList.add('promo-hidden'); promoShown = false; }


      // === SPRITE (ảnh PNG của bạn) ===
      const SPRITE = new Image();
      SPRITE.src = "dino_s.png"; // TODO: đổi thành URL/đường dẫn ảnh của bạn
      // ---- KÍCH THƯỚC DINO (chỉ đổi ở đây) ----


      const DINO_HEIGHT = 84; // đổi số này để to/nhỏ
      let DINO_WIDTH = 44;    // sẽ tính từ tỉ lệ ảnh khi ảnh load xong

      function applySpriteSize() {
        const aspect = (SPRITE.width && SPRITE.height) ? SPRITE.width / SPRITE.height : 1;
        DINO_WIDTH = Math.round(DINO_HEIGHT * aspect);
        dino.w = DINO_WIDTH;
        dino.h = DINO_HEIGHT;
        dino.y = groundYAt(dino.x) - dino.h;   // chân chạm đất
      }

      function onSpriteReady() {
        applySpriteSize();
        reset();            // chỉ reset khi ảnh đã sẵn sàng
        draw();             // vẽ lại màn hình chờ bằng ảnh thật
      }

      SPRITE.onload = onSpriteReady;
      // Nếu ảnh đã cache sẵn (load cực nhanh) thì gọi luôn:
      if (SPRITE.complete) onSpriteReady();


      // === HẰNG SỐ ===
      const GRAVITY = 0.7;
      const JUMP_VELOCITY = -15.5;
      const BASE_SPEED = 6;
      // --- VỊ TRÍ DINO THEO TỈ LỆ MÀN HÌNH ---
      const DINO_X_RATIO = 0.06;   // 6% bề ngang màn hình (đổi số nếu muốn sát/tránh mép)
      const DINO_X_MIN = 20;     // không cho sát mép quá

      function positionDinoX() {
        dino.x = Math.max(DINO_X_MIN, Math.round(cvs.width * DINO_X_RATIO));
      }

      // Địa hình: đường cơ sở dao động quanh 78% chiều cao
      const HILLS = {
        amp1: 21, len1: 700,   // sóng mượt, chu kỳ dài
        amp2: 10, len2: 400    // sóng phụ, chi tiết nhỏ
      };

      const startUI = document.getElementById('startUI');
      const btnStart = document.getElementById('btnStart');
      const btnMore = document.getElementById('btnMore');

      function showStartUI() { startUI.classList.remove('start-hidden'); }
      function hideStartUI() { startUI.classList.add('start-hidden'); }

      // click nút
      btnStart.onclick = () => { startUI.classList.add('start-hidden'); };

      btnMore.onclick = () => { window.open('https://ahafood.ai/store', '_blank', 'noopener'); };


      // === TRẠNG THÁI ===
      let groundBase;                 // y cơ sở (phụ thuộc kích thước màn hình)
      let scroll = 0;                 // offset cuộn thế giới
      let worldSpeed = BASE_SPEED;
      let tick = 0, score = 0;
      let hiscore = +localStorage.getItem('dino_hiscore_v4') || 0;
      let running = false, gameOver = false;
      // --- WEATHER STATE ---
      let weather = "day";         // day | night | rain
      let stars = [];
      let raindrops = [];

      let rafId = null;

      //nổ
      // --- EXPLOSION STATE ---
      let exploding = false;
      let particles = [];     // các hạt nổ
      const EXPLOSION_LIFE = 50;  // số frame tối đa mỗi hạt

      function spawnExplosion(cx, cy) {
        exploding = true;
        particles.length = 0;
        const count = 80; // số hạt nổ
        for (let i = 0; i < count; i++) {
          const ang = Math.random() * Math.PI * 2;
          const spd = 2.5 + Math.random() * 4.5;    // tốc độ ban đầu
          particles.push({
            x: cx, y: cy,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd - 2,            // hơi bốc lên
            life: EXPLOSION_LIFE,
            size: 2 + Math.random() * 3,
            color: (i % 3 === 0 ? '#f97316' : i % 3 === 1 ? '#facc15' : '#ef4444') // cam / vàng / đỏ
          });
        }
      }


      const dino = { x: 100, y: 0, vy: 0, w: 44, h: 52, onGround: false };
      dino.h = DINO_HEIGHT;
      dino.w = DINO_WIDTH;

      const obstacles = [], clouds = [];
      function rand(a, b) { return Math.random() * (b - a) + a }
      function irand(a, b) { return Math.floor(rand(a, b)) }

      // === ĐỊA HÌNH: y mặt đất tại toạ độ màn hình x (có tính cuộn) ===
      function groundYAt(screenX) {
        const worldX = scroll + screenX;
        // 2 sóng sin chồng nhau để tạo dốc mềm mại
        const y = groundBase
          + HILLS.amp1 * Math.sin((worldX) / HILLS.len1 * 2 * Math.PI)
          + HILLS.amp2 * Math.sin((worldX) / HILLS.len2 * 2 * Math.PI + 1.2);
        return y | 0;
      }

      function reset() {
        obstacles.length = 0; clouds.length = 0;
        // sau dòng: obstacles.length=0; clouds.length=0;
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }  // 🔴 dừng vòng lặp cũ nếu còn
        exploding = false;            // 🔴 tắt trạng thái nổ
        particles.length = 0;         // 🔴 xóa hạt nổ

        for (let i = 0; i < 4; i++) clouds.push({ x: rand(cvs.width, cvs.width * 2), y: rand(20, 120), s: rand(0.3, 0.8) });
        worldSpeed = BASE_SPEED; tick = 0; score = 0; scroll = 0; running = false; gameOver = false; dino.vy = 0;
        // --- WEATHER STATE ---
        let weather = "day";   // day | night | rain
        let stars = [];
        let raindrops = [];
        exploding = false;
        particles.length = 0;

        positionDinoX();
        dino.y = groundYAt(dino.x) - dino.h; dino.onGround = true;
        hidePromo();          // ẩn overlay khi bắt đầu lại
        promoShown = false;   // reset cờ
        showStartUI();     // hiện lại màn hình chờ khi reset

        draw();
        stars.length = 0;
        raindrops.length = 0;
        weather = "day";
      }

      function start() {
        if (!running && !gameOver) {
          hideStartUI();   // ẩn màn hình chờ
          running = true;  // (phần còn lại giữ nguyên)
          loop();
        }
      }


      function spawnObstacle() {
        const type = Math.random() < 0.6 ? 'cactus' : 'hole';
        if (type === 'cactus') {
          const count = irand(1, 4), parts = []; let totalW = 0;
          for (let i = 0; i < count; i++) { const w = irand(14, 24), h = irand(36, 64); parts.push({ w, h }); totalW += w + 8; }
          obstacles.push({ type, x: cvs.width + 20, parts, w: totalW, passed: false });
        } else {
          const w = irand(46, 95);
          obstacles.push({ type, x: cvs.width + 20, w, passed: false });
        }
      }

      function loop() {
        if (!running && !exploding) return;
        update();
        draw();
        rafId = requestAnimationFrame(loop);   // lưu id để có thể hủy
      }



      function update() {
        tick++;
        worldSpeed = BASE_SPEED + Math.min(6, Math.floor(score / 150));
        scroll += worldSpeed;

        if (tick % irand(70, 110) === 0) spawnObstacle();

        // physics dino
        dino.vy += GRAVITY;
        dino.y += dino.vy;
        const feetTarget = groundYAt(dino.x) - dino.h;
        if (dino.y >= feetTarget) { dino.y = feetTarget; dino.vy = 0; dino.onGround = true; }
        else dino.onGround = false;

        // parallax mây
        for (const c of clouds) {
          c.x -= worldSpeed * 0.25 * c.s;
          if (c.x < -60) { c.x = cvs.width + rand(40, 200); c.y = rand(20, 120); }
        }

        // di chuyển chướng ngại vật theo cuộn
        for (const ob of obstacles) { ob.x -= worldSpeed; }
        while (obstacles.length && obstacles[0].x + (obstacles[0].w || 40) < -40) obstacles.shift();

        // điểm
        score++;


        // --- weather cycle ---
        const cycle = score % 1000;  // lặp lại sau 1000 điểm
        if (cycle < 300) {
          weather = "day";
        } else if (cycle < 500) {
          weather = "night";
        } else if (cycle < 1000) {
          weather = "rain";
        }

        updateWeather();
        if (score > hiscore) { hiscore = score; localStorage.setItem('dino_hiscore_v4', hiscore); }


        // --- update explosion ---
        if (exploding) {
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.vy += 0.35;          // trọng lực nhẹ
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
          }
          if (particles.length === 0) {
            exploding = false;
            running = false;
            if (gameOver) showPromo();   // ✅ hiện CTA khi nổ xong
          }
        }
        // va chạm
        for (const ob of obstacles) {
          if (!ob.passed && (ob.x + (ob.w || 40)) < dino.x) ob.passed = true;
          if (hitTest(ob)) {
            gameOver = true;
            if (!exploding) {
              // tâm nổ tại giữa nhân vật
              spawnExplosion(dino.x + dino.w / 2, dino.y + dino.h / 2);
            }
            break;
          }
        }

      }

      // === VA CHẠM ===
      function hitTest(ob) {
        const dx = dino.x, dy = dino.y, dw = dino.w, dh = dino.h;

        if (ob.type === 'cactus') {
          let xCursor = ob.x;
          for (const p of ob.parts) {
            const cx = xCursor;
            const cy = groundYAt(cx) - p.h; // đỉnh cột xương rồng bám mặt đất dốc
            if (rectsOverlap(dx, dy, dw, dh, cx, cy, p.w, p.h)) return true;
            xCursor += p.w + 8;
          }
          return false;
        } else {
          const hx = ob.x, hw = ob.w;
          const hy = groundYAt(hx); // mặt đất tại vị trí hố
          const nearGround = dino.y + dino.h > hy - 4;
          const overlapX = (dx + dw) > hx && dx < (hx + hw);
          return nearGround && overlapX;
        }
      }
      function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
      }

      // === VẼ ===
      function drawGround() {
        // Vẽ dải đất theo đường cong mặt đất
        const bottom = cvs.height;
        ctx.save();
        ctx.fillStyle = '#f5b942';
        ctx.beginPath();
        ctx.moveTo(0, groundYAt(0));
        // lấy mẫu theo bước 8px để mượt
        for (let x = 8; x <= cvs.width; x += 8) {
          ctx.lineTo(x, groundYAt(x));
        }
        ctx.lineTo(cvs.width, bottom);
        ctx.lineTo(0, bottom);
        ctx.closePath();
        ctx.fill();

        // hột cát lấm tấm
        for (let i = 0; i < 50; i++) {
          ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.08})`;
          const rx = irand(0, cvs.width);
          const ry = irand(groundYAt(rx) + 6, bottom - 4);
          ctx.fillRect(rx, ry, 2, 2);
        }
        ctx.restore();
      }



      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.5)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }

      function drawCloud(x, y) {
        ctx.save(); ctx.translate(x, y); ctx.globalAlpha = .9; ctx.fillStyle = '#fff';
        blob(0, 0, 18); blob(16, -6, 14); blob(30, 0, 16); blob(10, 6, 12);
        ctx.restore();
      }
      function blob(x, y, r) { ctx.beginPath(); ctx.ellipse(x, y, r * 1.2, r, 0, 0, Math.PI * 2); ctx.fill(); }

      function drawDino() {
        const img = SPRITE;
        // fallback nếu ảnh chưa tải xong
        if (!img.complete || !img.width) {
          ctx.fillStyle = '#6c5ce7';
          ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
          return;
        }
        const scale = Math.min(dino.w / img.width, dino.h / img.height);
        const dw = (img.width * scale) | 0, dh = (img.height * scale) | 0;
        const dx = (dino.x + (dino.w - dw) / 2) | 0;
        const dy = (dino.y + (dino.h - dh)) | 0;

        // bóng chân nhẹ
        ctx.save();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(dino.x + dino.w / 2, dino.y + dino.h + 2, Math.max(14, dino.w * 0.35), 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, dx, dy, dw, dh);
      }

      function drawCactus(ob) {
        let xCursor = ob.x;
        for (const p of ob.parts) {
          const cx = xCursor;
          const cy = groundYAt(cx) - p.h;
          // thân
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cactus');
          roundRect(cx, cy, p.w, p.h, 4, ctx.fillStyle);
          // nhánh nhỏ
          ctx.fillStyle = '#13a66a';
          const armH = Math.min(18, p.h * 0.45);
          ctx.fillRect(cx - 6, cy + p.h * 0.4, 6, armH);
          ctx.fillRect(cx + p.w, cy + p.h * 0.25, 6, armH);
          xCursor += p.w + 8;
        }
      }

      function drawHole(ob) {
        const hy = groundYAt(ob.x);
        ctx.save();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--hole');
        ctx.beginPath();
        ctx.ellipse(ob.x + ob.w / 2, hy + 8, ob.w / 2, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = .2; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(ob.x + ob.w / 2, hy + 6, ob.w / 2.3, 6, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      function roundRect(x, y, w, h, r, fill) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
      }

      function drawHUD() {
        ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = 'bold 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.fillText(`Điểm: ${String(score).padStart(5, '0')}`, 16, 28);
        ctx.fillText(`Kỷ lục: ${String(hiscore).padStart(5, '0')}`, 16, 50);
      }

      function drawGameOver() {
        ctx.save(); ctx.fillStyle = 'rgba(15,23,42,.9)';
        ctx.font = '700 28px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', cvs.width / 2, cvs.height / 2 - 8);
        ctx.font = '600 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
        ctx.fillText('Nhấn Space hoặc chạm để chơi lại', cvs.width / 2, cvs.height / 2 + 18);
        ctx.restore();
      }

      function updateWeather() {
        if (weather === "night") {
          // sinh sao
          if (stars.length < 80) {
            stars.push({ x: Math.random() * cvs.width, y: Math.random() * cvs.height * 0.5, r: Math.random() * 2 + 1 });
          }
        } else {
          stars.length = 0;
        }

        if (weather === "rain") {
          // mưa
          if (raindrops.length < 200) {
            raindrops.push({ x: Math.random() * cvs.width, y: -10, vy: 8 + Math.random() * 4 });
          }
          for (let r of raindrops) {
            r.y += r.vy;
            if (r.y > cvs.height) { r.x = Math.random() * cvs.width; r.y = -10; }
          }
        } else {
          raindrops.length = 0;
        }
      }

      function drawWeather() {
        if (weather === "night") {
          ctx.fillStyle = "rgba(0,0,30,0.45)";
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = "#fff";
          for (let s of stars) {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
          }
        }
        if (weather === "rain") {
          ctx.strokeStyle = "rgba(100,150,255,0.7)";
          ctx.beginPath();
          for (let r of raindrops) {
            ctx.moveTo(r.x, r.y); ctx.lineTo(r.x, r.y + 8);
          }
          ctx.stroke();
        }
      }


      function draw() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        // mây
        for (const c of clouds) drawCloud(c.x, c.y);

        // đất dốc
        drawGround();

        // chướng ngại vật
        for (const ob of obstacles) { if (ob.type === 'cactus') drawCactus(ob); else drawHole(ob); }

        // dino (ẩn khi đang nổ để có cảm giác tan biến)
        if (!exploding) drawDino();

        // explosion particles
        if (exploding) drawExplosion();

        function drawExplosion() {
          for (const p of particles) {
            const alpha = Math.max(0, p.life / EXPLOSION_LIFE); // mờ dần
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
        // dino
        if (!exploding) drawDino();
        if (exploding) drawExplosion();

        // thời tiết
        drawWeather();     // ✅ thêm dòng này ở đây



        // HUD
        drawHUD();

        if (!running && !gameOver) {
          if (coverReady) {
            const iconSize = 120; // 120x120
            const x = (cvs.width - iconSize) / 2;
            const y = (cvs.height - iconSize) / 2;
            ctx.drawImage(COVER, x, y, iconSize, iconSize);
          }
        }

        if (gameOver) drawGameOver();
      }

      // === ĐIỀU KHIỂN ===
      function jump() { start(); if (dino.onGround) { dino.vy = JUMP_VELOCITY; dino.onGround = false; } }

      document.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          if (gameOver) { reset(); start(); } else jump();
        }
        if (e.code === 'KeyR') { reset(); start(); }
      });
      cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        if (gameOver) { reset(); start(); return; }
        jump();
      }, { passive: false });

      // === RESPONSIVE ===
      function resizeCanvas() {
        cvs.width = window.innerWidth;
        cvs.height = window.innerHeight;
        positionDinoX();
        groundBase = cvs.height * 0.78;
        dino.y = groundYAt(dino.x) - dino.h;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();


    })();
  </script>
</body>

</html>